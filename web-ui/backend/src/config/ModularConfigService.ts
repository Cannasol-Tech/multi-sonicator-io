/**
 * Generated by Agile Flow™ Agentic Framework
 * Modular Configuration Service for Web-UI Backend
 * Integrates Python config loader with Node.js backend
 */

import { spawn, ChildProcess } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import { EventEmitter } from 'events';

export interface ConfigModule {
  name: string;
  file_path: string;
  description: string;
  scope: string;
  last_updated: string;
  loaded: boolean;
  data?: any;
}

export interface ModularConfig {
  metadata: {
    name: string;
    description: string;
    version: string;
    last_updated: string;
    author: string;
    company: string;
  };
  project: {
    name: string;
    description: string;
    version: string;
    status: string;
  };
  configuration_modules: Record<string, ConfigModule>;
  architecture: any;
  environments: any;
}

export interface PinConfig {
  pin: number;
  signal: string;
  direction: string;
  sonicator?: number;
  function: string;
  modbus_register?: string;
  modbus_address?: string;
  adc_channel?: number;
  scaling?: string;
  test_point?: string;
}

export interface SonicatorConfig {
  id: number;
  name: string;
  description: string;
  hardware: {
    db9_connector: string;
    modbus_base_address: number;
    register_stride: number;
  };
  specifications: {
    model: string;
    power_rating_watts: number;
    frequency_nominal_hz: number;
    frequency_range_hz: number[];
    amplitude_range_percent: number[];
  };
  status: {
    connection_status: string;
    test_harness_support: boolean;
    production_ready: boolean;
    notes: string;
  };
}

export interface DB9Config {
  description: string;
  connector_type: string;
  function: string;
  location: string;
  sonicator_id?: number;
  pins: Record<string, {
    signal: string;
    dut_pin: string;
    direction: string;
    function: string;
    electrical: string;
    modbus_register?: string;
  }>;
  status: string;
}

export interface ModbusConfig {
  protocol: string;
  mode: string;
  slave_id: number;
  serial: {
    baud_rate: number;
    data_bits: number;
    stop_bits: number;
    parity: string;
    flow_control: string;
  };
  timing: {
    response_timeout_ms: number;
    frame_timeout_ms: number;
    inter_frame_delay_ms: number;
  };
  function_codes: Array<{
    code: number;
    name: string;
    description: string;
    supported: boolean;
  }>;
}

export interface ValidationError {
  type: string;
  message: string;
  module?: string;
  severity: 'error' | 'warning' | 'info';
}

export class ModularConfigService extends EventEmitter {
  private configDir: string;
  private pythonScript: string;
  private masterConfig: ModularConfig | null = null;
  private moduleData: Record<string, any> = {};
  private validationErrors: ValidationError[] = [];
  private lastLoadTime: Date | null = null;

  constructor(configDir?: string) {
    super();

    // Default to project root config directory
    this.configDir = configDir || path.resolve(__dirname, '../../../config');
    this.pythonScript = path.resolve(__dirname, '../../../scripts/config-loader.py');
    
    // Verify paths exist - log warnings but don't fail
    if (!fs.existsSync(this.configDir)) {
      console.warn(`⚠️  Configuration directory not found: ${this.configDir}`);
      console.warn(`⚠️  Modular configuration features will be disabled`);
    }

    if (!fs.existsSync(this.pythonScript)) {
      console.warn(`⚠️  Python config loader not found: ${this.pythonScript}`);
      console.warn(`⚠️  Modular configuration features will be disabled`);
    }
  }

  /**
   * Load the complete modular configuration
   */
  async loadConfiguration(): Promise<ModularConfig> {
    // Check if configuration is available
    if (!fs.existsSync(this.configDir) || !fs.existsSync(this.pythonScript)) {
      throw new Error('Modular configuration system not available - missing config directory or Python script');
    }

    try {
      const result = await this.executePythonScript(['--validate']);

      if (result.success) {
        // Load master configuration
        const masterConfigPath = path.join(this.configDir, 'sonic-multiplexer.yaml');
        const masterConfigData = await this.loadYamlFile(masterConfigPath);

        this.masterConfig = masterConfigData as ModularConfig;
        this.lastLoadTime = new Date();

        // Load all module data
        await this.loadAllModules();

        this.emit('configurationLoaded', this.masterConfig);
        return this.masterConfig;
      } else {
        throw new Error(`Configuration validation failed: ${result.error}`);
      }
    } catch (error) {
      this.emit('configurationError', error);
      throw error;
    }
  }

  /**
   * Load all configuration modules
   */
  private async loadAllModules(): Promise<void> {
    if (!this.masterConfig?.configuration_modules) {
      throw new Error('Master configuration not loaded');
    }

    const modules = this.masterConfig.configuration_modules;
    
    for (const [moduleName, moduleInfo] of Object.entries(modules)) {
      try {
        const moduleData = await this.loadYamlFile(moduleInfo.file_path);
        this.moduleData[moduleName] = moduleData;
        moduleInfo.loaded = true;
        moduleInfo.data = moduleData;
      } catch (error) {
        console.error(`Failed to load module ${moduleName}:`, error);
        moduleInfo.loaded = false;
        this.validationErrors.push({
          type: 'module_load_error',
          message: `Failed to load module ${moduleName}: ${error}`,
          module: moduleName,
          severity: 'error'
        });
      }
    }
  }

  /**
   * Get configuration for a specific pin
   */
  async getPinConfig(pinName: string): Promise<PinConfig | null> {
    const result = await this.executePythonScript(['--pin', pinName]);
    return result.success ? result.data : null;
  }

  /**
   * Get configuration for a specific sonicator
   */
  async getSonicatorConfig(sonicatorId: number): Promise<SonicatorConfig | null> {
    const result = await this.executePythonScript(['--sonicator', sonicatorId.toString()]);
    return result.success ? result.data : null;
  }

  /**
   * Get configuration for a specific DB9 connector
   */
  async getDB9Config(connectorName: string): Promise<DB9Config | null> {
    const result = await this.executePythonScript(['--db9', connectorName]);
    return result.success ? result.data : null;
  }

  /**
   * Get MODBUS configuration
   */
  getModbusConfig(): ModbusConfig | null {
    const commData = this.moduleData['communication'];
    return commData?.modbus || null;
  }

  /**
   * Get all pin configurations
   */
  getAllPinConfigs(): Record<string, PinConfig> {
    const pinoutData = this.moduleData['pinout'];
    return pinoutData?.dut?.pins || {};
  }

  /**
   * Get all sonicator configurations
   */
  getAllSonicatorConfigs(): SonicatorConfig[] {
    const sonicatorData = this.moduleData['sonicators'];
    return sonicatorData?.sonicators || [];
  }

  /**
   * Get all DB9 connector configurations
   */
  getAllDB9Configs(): Record<string, DB9Config> {
    const connectionsData = this.moduleData['connections'];
    return connectionsData?.db9_connectors || {};
  }

  /**
   * Validate the complete configuration
   */
  async validateConfiguration(): Promise<{ valid: boolean; errors: ValidationError[] }> {
    try {
      const result = await this.executePythonScript(['--validate']);
      
      this.validationErrors = result.errors || [];
      
      return {
        valid: result.success && this.validationErrors.length === 0,
        errors: this.validationErrors
      };
    } catch (error) {
      const validationError: ValidationError = {
        type: 'validation_error',
        message: `Validation failed: ${error}`,
        severity: 'error'
      };
      
      this.validationErrors = [validationError];
      
      return {
        valid: false,
        errors: this.validationErrors
      };
    }
  }

  /**
   * Save configuration module
   */
  async saveModule(moduleName: string, data: any): Promise<boolean> {
    try {
      if (!this.masterConfig?.configuration_modules[moduleName]) {
        throw new Error(`Unknown module: ${moduleName}`);
      }

      const moduleInfo = this.masterConfig.configuration_modules[moduleName];
      const filePath = moduleInfo.file_path;
      
      // Convert data to YAML and save
      const yaml = require('js-yaml');
      const yamlContent = yaml.dump(data, {
        indent: 2,
        lineWidth: 120,
        noRefs: true
      });
      
      await fs.promises.writeFile(filePath, yamlContent, 'utf8');
      
      // Update in-memory data
      this.moduleData[moduleName] = data;
      moduleInfo.data = data;
      moduleInfo.last_updated = new Date().toISOString().split('T')[0];
      
      // Validate after save
      const validation = await this.validateConfiguration();
      
      this.emit('moduleUpdated', { moduleName, data, valid: validation.valid });
      
      return validation.valid;
    } catch (error) {
      this.emit('moduleUpdateError', { moduleName, error });
      throw error;
    }
  }

  /**
   * Export combined configuration for backward compatibility
   */
  async exportCombinedConfig(outputPath?: string): Promise<string> {
    const exportPath = outputPath || path.join(this.configDir, 'combined-config.yaml');
    
    const result = await this.executePythonScript(['--export', exportPath]);
    
    if (result.success) {
      return exportPath;
    } else {
      throw new Error(`Export failed: ${result.error}`);
    }
  }

  /**
   * Get configuration summary
   */
  getConfigurationSummary(): any {
    return {
      masterConfig: this.masterConfig,
      modules: Object.keys(this.moduleData).map(name => ({
        name,
        loaded: this.masterConfig?.configuration_modules[name]?.loaded || false,
        lastUpdated: this.masterConfig?.configuration_modules[name]?.last_updated
      })),
      validationErrors: this.validationErrors,
      lastLoadTime: this.lastLoadTime
    };
  }

  /**
   * Execute Python configuration script
   */
  private async executePythonScript(args: string[]): Promise<any> {
    return new Promise((resolve, reject) => {
      const pythonArgs = [
        this.pythonScript,
        '--config-dir', this.configDir,
        ...args
      ];

      const python = spawn('python3', pythonArgs, {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      python.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      python.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      python.on('close', (code) => {
        if (code === 0) {
          try {
            // Try to parse JSON output from Python script
            const lines = stdout.split('\n').filter(line => line.trim());
            const jsonLine = lines.find(line => line.startsWith('{'));
            
            if (jsonLine) {
              const result = JSON.parse(jsonLine);
              resolve({ success: true, data: result });
            } else {
              resolve({ success: true, output: stdout });
            }
          } catch (error) {
            resolve({ success: true, output: stdout });
          }
        } else {
          reject(new Error(`Python script failed with code ${code}: ${stderr}`));
        }
      });

      python.on('error', (error) => {
        reject(new Error(`Failed to execute Python script: ${error.message}`));
      });
    });
  }

  /**
   * Load YAML file
   */
  private async loadYamlFile(filePath: string): Promise<any> {
    try {
      const yaml = require('js-yaml');
      const content = await fs.promises.readFile(filePath, 'utf8');
      return yaml.load(content);
    } catch (error) {
      throw new Error(`Failed to load YAML file ${filePath}: ${error}`);
    }
  }

  /**
   * Get module data by name
   */
  getModuleData(moduleName: string): any {
    return this.moduleData[moduleName] || null;
  }

  /**
   * Check if modular configuration system is available
   */
  isAvailable(): boolean {
    return fs.existsSync(this.configDir) && fs.existsSync(this.pythonScript);
  }

  /**
   * Check if configuration is loaded
   */
  isLoaded(): boolean {
    return this.masterConfig !== null;
  }

  /**
   * Get last load time
   */
  getLastLoadTime(): Date | null {
    return this.lastLoadTime;
  }

  /**
   * Reload configuration
   */
  async reloadConfiguration(): Promise<ModularConfig> {
    this.masterConfig = null;
    this.moduleData = {};
    this.validationErrors = [];
    this.lastLoadTime = null;
    
    return await this.loadConfiguration();
  }
}

// Singleton instance
export const modularConfigService = new ModularConfigService();
