#!/usr/bin/env python3
"""
Generated by Agile Flow™ Agentic Framework
Multi-Sonicator-IO Modular Configuration Loader
Utility for loading and validating modular YAML configuration files
"""

import yaml
import os
import sys
from pathlib import Path
from typing import Dict, Any, Optional, List
import argparse
from dataclasses import dataclass
from datetime import datetime

@dataclass
class ConfigModule:
    """Configuration module metadata"""
    name: str
    file_path: str
    description: str
    scope: str
    last_updated: str
    loaded: bool = False
    data: Optional[Dict[Any, Any]] = None

class ModularConfigLoader:
    """
    Modular YAML configuration loader for Multi-Sonicator-IO system
    
    Loads and validates the modular configuration structure with:
    - Master configuration (sonic-multiplexer.yaml)
    - Pinout configuration (pinout-cfg.yaml)
    - Connections configuration (connections-cfg.yaml)
    - Communication configuration (communication-cfg.yaml)
    - Sonicator configuration (sonicator-cfg.yaml)
    """
    
    def __init__(self, config_dir: str = "config"):
        """
        Initialize the configuration loader
        
        Args:
            config_dir: Directory containing configuration files
        """
        self.config_dir = Path(config_dir)
        self.master_config: Optional[Dict[Any, Any]] = None
        self.modules: Dict[str, ConfigModule] = {}
        self.validation_errors: List[str] = []
        
    def load_master_config(self, master_file: str = "sonic-multiplexer.yaml") -> bool:
        """
        Load the master configuration file
        
        Args:
            master_file: Master configuration filename
            
        Returns:
            True if loaded successfully, False otherwise
        """
        master_path = self.config_dir / master_file
        
        try:
            with open(master_path, 'r') as f:
                self.master_config = yaml.safe_load(f)
                
            # Extract module information from master config
            if 'configuration_modules' in self.master_config:
                for module_name, module_info in self.master_config['configuration_modules'].items():
                    self.modules[module_name] = ConfigModule(
                        name=module_name,
                        file_path=module_info['file'],
                        description=module_info['description'],
                        scope=module_info['scope'],
                        last_updated=module_info['last_updated']
                    )
                    
            print(f"✅ Master configuration loaded: {master_path}")
            return True
            
        except FileNotFoundError:
            self.validation_errors.append(f"Master configuration file not found: {master_path}")
            return False
        except yaml.YAMLError as e:
            self.validation_errors.append(f"YAML parsing error in {master_path}: {e}")
            return False
        except Exception as e:
            self.validation_errors.append(f"Error loading {master_path}: {e}")
            return False
    
    def load_module(self, module_name: str) -> bool:
        """
        Load a specific configuration module
        
        Args:
            module_name: Name of the module to load
            
        Returns:
            True if loaded successfully, False otherwise
        """
        if module_name not in self.modules:
            self.validation_errors.append(f"Unknown module: {module_name}")
            return False
            
        module = self.modules[module_name]
        module_path = Path(module.file_path)
        
        try:
            with open(module_path, 'r') as f:
                module.data = yaml.safe_load(f)
                module.loaded = True
                
            print(f"✅ Module loaded: {module_name} ({module_path})")
            return True
            
        except FileNotFoundError:
            self.validation_errors.append(f"Module file not found: {module_path}")
            return False
        except yaml.YAMLError as e:
            self.validation_errors.append(f"YAML parsing error in {module_path}: {e}")
            return False
        except Exception as e:
            self.validation_errors.append(f"Error loading {module_path}: {e}")
            return False
    
    def load_all_modules(self) -> bool:
        """
        Load all configuration modules
        
        Returns:
            True if all modules loaded successfully, False otherwise
        """
        success = True
        
        for module_name in self.modules.keys():
            if not self.load_module(module_name):
                success = False
                
        return success
    
    def get_module_data(self, module_name: str) -> Optional[Dict[Any, Any]]:
        """
        Get data from a specific module
        
        Args:
            module_name: Name of the module
            
        Returns:
            Module data dictionary or None if not loaded
        """
        if module_name not in self.modules:
            return None
            
        module = self.modules[module_name]
        if not module.loaded:
            self.load_module(module_name)
            
        return module.data
    
    def get_pin_config(self, pin_name: str) -> Optional[Dict[Any, Any]]:
        """
        Get configuration for a specific pin
        
        Args:
            pin_name: Pin name (e.g., "PB0", "PC1")
            
        Returns:
            Pin configuration dictionary or None if not found
        """
        pinout_data = self.get_module_data('pinout')
        if not pinout_data:
            return None
            
        pins = pinout_data.get('dut', {}).get('pins', {})
        return pins.get(pin_name)
    
    def get_sonicator_config(self, sonicator_id: int) -> Optional[Dict[Any, Any]]:
        """
        Get configuration for a specific sonicator
        
        Args:
            sonicator_id: Sonicator ID (1-4)
            
        Returns:
            Sonicator configuration dictionary or None if not found
        """
        sonicator_data = self.get_module_data('sonicators')
        if not sonicator_data:
            return None
            
        sonicators = sonicator_data.get('sonicators', [])
        for sonicator in sonicators:
            if sonicator.get('id') == sonicator_id:
                return sonicator
                
        return None
    
    def get_db9_config(self, connector_name: str) -> Optional[Dict[Any, Any]]:
        """
        Get configuration for a specific DB9 connector
        
        Args:
            connector_name: Connector name (e.g., "DB9-1", "DB9-4")
            
        Returns:
            DB9 connector configuration dictionary or None if not found
        """
        connections_data = self.get_module_data('connections')
        if not connections_data:
            return None
            
        connectors = connections_data.get('db9_connectors', {})
        return connectors.get(connector_name)
    
    def get_modbus_config(self) -> Optional[Dict[Any, Any]]:
        """
        Get MODBUS configuration
        
        Returns:
            MODBUS configuration dictionary or None if not found
        """
        comm_data = self.get_module_data('communication')
        if not comm_data:
            return None
            
        return comm_data.get('modbus')
    
    def validate_configuration(self) -> bool:
        """
        Validate the complete configuration for consistency
        
        Returns:
            True if validation passes, False otherwise
        """
        self.validation_errors.clear()
        
        # Validate that all modules are loaded
        for module_name, module in self.modules.items():
            if not module.loaded:
                self.validation_errors.append(f"Module not loaded: {module_name}")
        
        # Cross-validate pin assignments
        self._validate_pin_assignments()
        
        # Cross-validate DB9 connections
        self._validate_db9_connections()
        
        # Cross-validate sonicator mappings
        self._validate_sonicator_mappings()
        
        return len(self.validation_errors) == 0
    
    def _validate_pin_assignments(self):
        """Validate pin assignments for conflicts"""
        pinout_data = self.get_module_data('pinout')
        if not pinout_data:
            return
            
        pins = pinout_data.get('dut', {}).get('pins', {})
        used_pins = set()
        
        for pin_name, pin_config in pins.items():
            physical_pin = pin_config.get('pin')
            if physical_pin in used_pins:
                self.validation_errors.append(f"Pin conflict: Physical pin {physical_pin} used by multiple signals")
            used_pins.add(physical_pin)
    
    def _validate_db9_connections(self):
        """Validate DB9 connector pin assignments"""
        connections_data = self.get_module_data('connections')
        if not connections_data:
            return
            
        connectors = connections_data.get('db9_connectors', {})
        
        for connector_name, connector_config in connectors.items():
            pins = connector_config.get('pins', {})
            for pin_num, pin_config in pins.items():
                dut_pin = pin_config.get('dut_pin')
                if dut_pin:
                    # Validate that DUT pin exists in pinout configuration
                    pin_config_data = self.get_pin_config(dut_pin)
                    if not pin_config_data:
                        self.validation_errors.append(f"DB9 {connector_name} pin {pin_num} references unknown DUT pin: {dut_pin}")
    
    def _validate_sonicator_mappings(self):
        """Validate sonicator to hardware mappings"""
        sonicator_data = self.get_module_data('sonicators')
        if not sonicator_data:
            return
            
        sonicators = sonicator_data.get('sonicators', [])
        
        for sonicator in sonicators:
            sonicator_id = sonicator.get('id')
            db9_connector = sonicator.get('hardware', {}).get('db9_connector')
            
            if db9_connector:
                # Validate that DB9 connector exists
                db9_config = self.get_db9_config(db9_connector)
                if not db9_config:
                    self.validation_errors.append(f"Sonicator {sonicator_id} references unknown DB9 connector: {db9_connector}")
    
    def print_summary(self):
        """Print configuration summary"""
        print("\n" + "="*80)
        print("MULTI-SONICATOR-IO MODULAR CONFIGURATION SUMMARY")
        print("="*80)
        
        if self.master_config:
            project = self.master_config.get('project', {})
            print(f"Project: {project.get('name', 'Unknown')}")
            print(f"Version: {project.get('version', 'Unknown')}")
            print(f"Description: {project.get('description', 'Unknown')}")
            print()
        
        print("Configuration Modules:")
        for module_name, module in self.modules.items():
            status = "✅ LOADED" if module.loaded else "❌ NOT LOADED"
            print(f"  {module_name:15} {status:12} {module.description}")
        
        print(f"\nValidation: {'✅ PASSED' if len(self.validation_errors) == 0 else '❌ FAILED'}")
        
        if self.validation_errors:
            print("\nValidation Errors:")
            for error in self.validation_errors:
                print(f"  ❌ {error}")
        
        print("="*80)
    
    def export_combined_config(self, output_file: str = "combined-config.yaml"):
        """
        Export a combined configuration file for backward compatibility
        
        Args:
            output_file: Output filename
        """
        if not all(module.loaded for module in self.modules.values()):
            print("❌ Cannot export: Not all modules are loaded")
            return False
            
        combined = {
            'metadata': {
                'generated_by': 'ModularConfigLoader',
                'generated_at': datetime.now().isoformat(),
                'source': 'Modular YAML configuration',
                'warning': 'This is a generated file - edit source modules instead'
            }
        }
        
        # Add master config
        if self.master_config:
            combined['project'] = self.master_config.get('project', {})
            combined['architecture'] = self.master_config.get('architecture', {})
        
        # Add module data
        for module_name, module in self.modules.items():
            if module.loaded and module.data:
                combined[module_name] = module.data
        
        try:
            with open(output_file, 'w') as f:
                yaml.dump(combined, f, default_flow_style=False, sort_keys=False)
            print(f"✅ Combined configuration exported: {output_file}")
            return True
        except Exception as e:
            print(f"❌ Export failed: {e}")
            return False

def main():
    """Main function for command-line usage"""
    parser = argparse.ArgumentParser(description='Multi-Sonicator-IO Modular Configuration Loader')
    parser.add_argument('--config-dir', default='config', help='Configuration directory')
    parser.add_argument('--master-file', default='sonic-multiplexer.yaml', help='Master configuration file')
    parser.add_argument('--validate', action='store_true', help='Validate configuration')
    parser.add_argument('--export', help='Export combined configuration to file')
    parser.add_argument('--pin', help='Show configuration for specific pin')
    parser.add_argument('--sonicator', type=int, help='Show configuration for specific sonicator')
    parser.add_argument('--db9', help='Show configuration for specific DB9 connector')
    
    args = parser.parse_args()
    
    # Initialize loader
    loader = ModularConfigLoader(args.config_dir)
    
    # Load master configuration
    if not loader.load_master_config(args.master_file):
        print("❌ Failed to load master configuration")
        sys.exit(1)
    
    # Load all modules
    if not loader.load_all_modules():
        print("❌ Failed to load all modules")
        sys.exit(1)
    
    # Validate if requested
    if args.validate:
        if loader.validate_configuration():
            print("✅ Configuration validation passed")
        else:
            print("❌ Configuration validation failed")
            sys.exit(1)
    
    # Show specific configurations
    if args.pin:
        pin_config = loader.get_pin_config(args.pin)
        if pin_config:
            print(f"\nPin {args.pin} Configuration:")
            print(yaml.dump(pin_config, default_flow_style=False))
        else:
            print(f"❌ Pin {args.pin} not found")
    
    if args.sonicator:
        sonicator_config = loader.get_sonicator_config(args.sonicator)
        if sonicator_config:
            print(f"\nSonicator {args.sonicator} Configuration:")
            print(yaml.dump(sonicator_config, default_flow_style=False))
        else:
            print(f"❌ Sonicator {args.sonicator} not found")
    
    if args.db9:
        db9_config = loader.get_db9_config(args.db9)
        if db9_config:
            print(f"\nDB9 {args.db9} Configuration:")
            print(yaml.dump(db9_config, default_flow_style=False))
        else:
            print(f"❌ DB9 {args.db9} not found")
    
    # Export if requested
    if args.export:
        loader.export_combined_config(args.export)
    
    # Print summary
    loader.print_summary()

if __name__ == '__main__':
    main()
