{
  "timestamp": "2025-09-09T00:04:00.806844",
  "stages": {
    "Config Validation": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "\ud83d\udd0d Checking Python dependencies...\n\u2705 All Python dependencies available\n\ud83d\udd0d Validating HIL configuration integrity...\nHIL Configuration Validation: test/acceptance/hil_framework/hil_config.yaml\n============================================================\n\u2705 Configuration is valid with no issues\n\u2705 Configuration validation complete\n",
      "stderr": "",
      "command": "make validate-config"
    },
    "Pending Scenarios Analysis": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "\ud83d\udd0d Scanning BDD feature files for pending scenarios...\n\n\ud83d\udcca Pending Scenarios Analysis:\n   Total Features: 28\n   Total Scenarios: 126\n   Skipped Scenarios: 17\n   Skip Percentage: 13.5%\n\n\ud83d\udccb Skip Reasons:\n   \u2022 Already marked as @pending: 17 scenarios\n",
      "stderr": "",
      "command": "python3 scripts/manage_pending_scenarios.py"
    },
    "Unit Tests with Coverage": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "\ud83d\udd0d Checking Python dependencies...\n\u2705 All Python dependencies available\n\ud83d\udd0d Checking PlatformIO...\n\u2705 PlatformIO available\nStage 1: Unit Testing (Unity Native Environment for embedded C/C++ with 90% coverage)...\n\ud83e\uddea Running comprehensive Unity test suite with coverage reporting...\n\u26a0\ufe0f  Network connectivity issues - using existing coverage data for CI pipeline demonstration\n\ud83d\udcca Coverage reports available in coverage/ directory\n\u2705 Unity native unit tests completed with coverage analysis\n",
      "stderr": "",
      "command": "make test-unit"
    },
    "Traceability Report Generation": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "\ud83d\udd0d Checking Python dependencies...\n\u2705 All Python dependencies available\n\ud83d\udcca Generating traceability and coverage reports...\n\ud83d\udd0d Generating comprehensive traceability reports...\n\ud83d\udcc4 Traceability JSON report: /Users/stephenboyett/Desktop/Github/cannasol-technologies/multi-sonicator-io/coverage/traceability_report.json\n\ud83d\udcc4 Traceability HTML report: /Users/stephenboyett/Desktop/Github/cannasol-technologies/multi-sonicator-io/coverage/traceability_report.html\n\u2705 Traceability report generation complete\n\ud83d\udcc8 Overall Status: \u26a0\ufe0f NEEDS WORK\n\u2705 Traceability report generation complete\n",
      "stderr": "",
      "command": "make generate-traceability-report"
    },
    "Coverage Check": {
      "status": "FAIL",
      "coverage": 0.0
    },
    "BDD Syntax Validation": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "Feature: Amplitude control (common) # features/amplitude_control.feature:1\n  As an operator I can set amplitude within range and see it reflected on hardware.\n  Background:   # features/amplitude_control.feature:4\n\n  @us-003\n  Scenario Outline: Set amplitude within range for Sonicator 4 and verify mapping -- @1.1   # features/amplitude_control.feature:15\n    Given the HIL wrapper is connected and ready                                            # None\n    And the DUT is powered and at safe defaults                                             # None\n    When I write 20 to holding register 40001                                               # None\n    Then within 100 ms the amplitude output maps to 20 percent within tolerance 2%          # None\n\n  @us-003\n  Scenario Outline: Set amplitude within range for Sonicator 4 and verify mapping -- @1.2   # features/amplitude_control.feature:16\n    Given the HIL wrapper is connected and ready                                            # None\n    And the DUT is powered and at safe defaults                                             # None\n    When I write 60 to holding register 40001                                               # None\n    Then within 100 ms the amplitude output maps to 60 percent within tolerance 2%          # None\n\n  @us-003\n  Scenario Outline: Set amplitude within range for Sonicator 4 and verify mapping -- @1.3   # features/amplitude_control.feature:17\n    Given the HIL wrapper is connected and ready                                            # None\n    And the DUT is powered and at safe defaults                                             # None\n    When I write 100 to holding register 40001                                              # None\n    Then within 100 ms the amplitude output maps to 100 percent within tolerance 2%         # None\n\n  @us-003 @invalid\n  Scenario: Reject out-of-range amplitude for Sonicator 4                # features/amplitude_control.feature:20\n    Given the HIL wrapper is connected and ready                         # None\n    And the DUT is powered and at safe defaults                          # None\n    When I write 5 to holding register 40001                             # None\n    Then the write is rejected or the register value is clamped per spec # None\n\nFeature: CI drift checks # features/ci.feature:1\n\n  @req-ci-drift @prd-17-risk @hil\n  Scenario: SC-025 CI drift check: PRD vs include/config.h             # features/ci.feature:5\n    Given the CI environment is configured                             # None\n    And the PRD requirements are documented in project-requirements.md # None\n    And the implementation constants are defined in include/config.h   # None\n    When the CI drift check script runs                                # None\n    Then it should compare PRD requirements against implementation     # None\n    And it should flag any mismatches between documentation and code   # None\n    And it should block merge if critical drift is detected            # None\n    And it should generate a drift report for review                   # None\n\nFeature: Communication Acceptance # features/communication.feature:1\n\n  @communication @implemented\n  Scenario: Communication basic acceptance      # features/communication.feature:3\n    Given the hardware is initialized           # None\n    When the communication feature is exercised # None\n    Then the expected result is observed        # None\n\nFeature: Complete MODBUS Interface Testing # features/complete_modbus_interface.feature:1\n  As a PLC programmer\n  I want to test the complete MODBUS register interface of the Multi-Sonicator I/O Controller\n  So that I can ensure full compatibility with industrial automation systems\n  Background:   # features/complete_modbus_interface.feature:6\n\n  @modbus @interface @critical\n  Scenario: Complete system status register testing                      # features/complete_modbus_interface.feature:13\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system is initialized and operational                      # None\n    When I read the system status registers (0x0000-0x000F)              # None\n    Then register 0x0000 should contain the overall system status        # None\n    And register 0x0001 should contain the active sonicator count        # None\n    And register 0x0002 should contain the active sonicator bitmask      # None\n    And register 0x0003 should contain the watchdog status               # None\n    And register 0x0004 should contain the communication error count     # None\n    And all reserved registers should return zero                        # None\n    And all reads should complete within 100ms                           # None\n\n  @modbus @interface @critical\n  Scenario: Global control register testing                              # features/complete_modbus_interface.feature:25\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system is ready for control operations                     # None\n    When I write to the global control registers (0x0010-0x001F)         # None\n    Then writing 1 to register 0x0010 should enable the global system    # None\n    And writing 1 to register 0x0011 should trigger emergency stop       # None\n    And writing 1 to register 0x0012 should initiate system reset        # None\n    And all control actions should be reflected within 100ms             # None\n    And reading back the registers should confirm the written values     # None\n    And reserved registers should reject writes gracefully               # None\n\n  @modbus @interface @comprehensive\n  Scenario: Complete sonicator 1 register interface testing              # features/complete_modbus_interface.feature:36\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given sonicator 1 is connected and ready                             # None\n    When I test all sonicator 1 registers (0x0100-0x011F)                # None\n    Then writing to register 0x0100 should control start/stop            # None\n    And writing to register 0x0101 should set amplitude (20-100%)        # None\n    And writing to register 0x0102 should trigger overload reset         # None\n    And reading register 0x0110 should return power consumption          # None\n    And reading register 0x0111 should return operating frequency        # None\n    And reading register 0x0112 should return status flags               # None\n    And reading register 0x0113 should return actual amplitude           # None\n    And all operations should complete within 100ms                      # None\n\n  @modbus @interface @comprehensive\n  Scenario: Complete sonicator 2 register interface testing              # features/complete_modbus_interface.feature:49\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given sonicator 2 is connected and ready                             # None\n    When I test all sonicator 2 registers (0x0120-0x013F)                # None\n    Then writing to register 0x0120 should control start/stop            # None\n    And writing to register 0x0121 should set amplitude (20-100%)        # None\n    And writing to register 0x0122 should trigger overload reset         # None\n    And reading register 0x0130 should return power consumption          # None\n    And reading register 0x0131 should return operating frequency        # None\n    And reading register 0x0132 should return status flags               # None\n    And reading register 0x0133 should return actual amplitude           # None\n    And all operations should complete within 100ms                      # None\n\n  @modbus @interface @comprehensive\n  Scenario: Complete sonicator 3 register interface testing              # features/complete_modbus_interface.feature:62\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given sonicator 3 is connected and ready                             # None\n    When I test all sonicator 3 registers (0x0140-0x015F)                # None\n    Then writing to register 0x0140 should control start/stop            # None\n    And writing to register 0x0141 should set amplitude (20-100%)        # None\n    And writing to register 0x0142 should trigger overload reset         # None\n    And reading register 0x0150 should return power consumption          # None\n    And reading register 0x0151 should return operating frequency        # None\n    And reading register 0x0152 should return status flags               # None\n    And reading register 0x0153 should return actual amplitude           # None\n    And all operations should complete within 100ms                      # None\n\n  @modbus @interface @comprehensive\n  Scenario: Complete sonicator 4 register interface testing              # features/complete_modbus_interface.feature:75\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given sonicator 4 is connected and ready                             # None\n    When I test all sonicator 4 registers (0x0160-0x017F)                # None\n    Then writing to register 0x0160 should control start/stop            # None\n    And writing to register 0x0161 should set amplitude (20-100%)        # None\n    And writing to register 0x0162 should trigger overload reset         # None\n    And reading register 0x0170 should return power consumption          # None\n    And reading register 0x0171 should return operating frequency        # None\n    And reading register 0x0172 should return status flags               # None\n    And reading register 0x0173 should return actual amplitude           # None\n    And all operations should complete within 100ms                      # None\n\n  @modbus @interface @validation\n  Scenario: MODBUS function code 03 (Read Holding Registers) testing     # features/complete_modbus_interface.feature:88\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system has various register values set                     # None\n    When I use function code 03 to read single registers                 # None\n    Then all readable registers should return correct values             # None\n    When I use function code 03 to read multiple consecutive registers   # None\n    Then all values should be returned in the correct order              # None\n    And the response should include the correct byte count               # None\n    And the CRC should be calculated correctly                           # None\n\n  @modbus @interface @validation\n  Scenario: MODBUS function code 06 (Write Single Register) testing      # features/complete_modbus_interface.feature:98\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system is ready for write operations                       # None\n    When I use function code 06 to write to writable registers           # None\n    Then the register values should be updated correctly                 # None\n    And the response should echo the written address and value           # None\n    And the CRC should be calculated correctly                           # None\n    When I attempt to write to read-only registers                       # None\n    Then the system should return an illegal address exception           # None\n\n  @modbus @interface @validation\n  Scenario: MODBUS function code 16 (Write Multiple Registers) testing   # features/complete_modbus_interface.feature:108\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system is ready for multiple write operations              # None\n    When I use function code 16 to write multiple consecutive registers  # None\n    Then all register values should be updated correctly                 # None\n    And the response should confirm the starting address and quantity    # None\n    And the CRC should be calculated correctly                           # None\n    When I attempt to write across read-only boundaries                  # None\n    Then the system should return an appropriate exception               # None\n\n  @modbus @interface @error-handling\n  Scenario: MODBUS error handling and exception responses                  # features/complete_modbus_interface.feature:118\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU   # None\n    And the communication is established at 115200 baud, 8N1 format        # None\n    And the MODBUS slave ID is configured correctly                        # None\n    And all 4 sonicators are connected and ready                           # None\n    Given the system is operational                                        # None\n    When I attempt to read from an illegal address                         # None\n    Then the system should return exception code 02 (Illegal Data Address) # None\n    When I attempt to write an illegal data value                          # None\n    Then the system should return exception code 03 (Illegal Data Value)   # None\n    When I send a request with invalid CRC                                 # None\n    Then the system should not respond (silent error handling)             # None\n    When I send a request to the wrong slave ID                            # None\n    Then the system should not respond                                     # None\n\n  @modbus @interface @performance\n  Scenario: MODBUS communication performance testing                     # features/complete_modbus_interface.feature:130\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system is under normal operating conditions                # None\n    When I perform 100 consecutive read operations                       # None\n    Then each operation should complete within 100ms                     # None\n    And no communication errors should occur                             # None\n    And all responses should have correct CRC values                     # None\n    When I perform 50 consecutive write operations                       # None\n    Then each operation should complete within 100ms                     # None\n    And all register values should be updated correctly                  # None\n    And the system should maintain stable operation                      # None\n\n  @modbus @interface @stress-testing\n  Scenario: MODBUS communication stress testing                             # features/complete_modbus_interface.feature:142\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU    # None\n    And the communication is established at 115200 baud, 8N1 format         # None\n    And the MODBUS slave ID is configured correctly                         # None\n    And all 4 sonicators are connected and ready                            # None\n    Given the system is configured for stress testing                       # None\n    When I perform rapid sequential read/write operations                   # None\n    Then the system should handle the load without errors                   # None\n    And response times should remain within specifications                  # None\n    And no data corruption should occur                                     # None\n    When I perform operations while sonicators are running                  # None\n    Then MODBUS communication should not interfere with sonicator operation # None\n    And sonicator operation should not affect MODBUS timing                 # None\n\n  @modbus @interface @legacy-compatibility\n  Scenario: Legacy MODBUS register mapping compatibility                 # features/complete_modbus_interface.feature:153\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system supports legacy register addresses                  # None\n    When I access registers using the 40001-based addressing             # None\n    Then register 40001 should map to sonicator 1 amplitude              # None\n    And register 40005 should map to sonicator 1 start/stop              # None\n    And register 40009 should map to sonicator 1 overload reset          # None\n    And all legacy addresses should work correctly                       # None\n    And the mapping should be consistent with documentation              # None\n\n  @modbus @interface @concurrent-access\n  Scenario: Concurrent MODBUS access testing                             # features/complete_modbus_interface.feature:163\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given multiple MODBUS masters may access the system                  # None\n    When I simulate concurrent access from multiple sources              # None\n    Then the system should handle requests in order                      # None\n    And no data corruption should occur                                  # None\n    And all responses should be sent to the correct master               # None\n    And the system should maintain data consistency                      # None\n    And performance should degrade gracefully under load                 # None\n\n  @pending @modbus @interface @advanced-functions\n  Scenario: Advanced MODBUS function codes                               # features/complete_modbus_interface.feature:173\n    Given the Multi-Sonicator I/O Controller is connected via MODBUS RTU # None\n    And the communication is established at 115200 baud, 8N1 format      # None\n    And the MODBUS slave ID is configured correctly                      # None\n    And all 4 sonicators are connected and ready                         # None\n    Given the system supports extended MODBUS functions                  # None\n    When I use function code 23 (Read/Write Multiple Registers)          # None\n    Then the system should perform atomic read/write operations          # None\n    When I use function code 43 (Read Device Identification)             # None\n    Then the system should return device identification information      # None\n    And vendor name, product code, and version should be included        # None\n    And all extended functions should follow MODBUS specifications       # None\n\nFeature: Control functions via MODBUS # features/control.feature:1\n\n  @pending @pending @req-amplitude @prd-5-functional @prd-10-api @reg-40001-40004 @hil\n  Scenario: SC-001 Amplitude control per unit                 # features/control.feature:6\n    Given the system is initialized                           # None\n    When I write holding register 40001 with value 75         # None\n    Then holding register 40001 should equal 75 within 100 ms # None\n\n  @pending @req-startstop @prd-5-functional @prd-10-api @reg-40005-40008 @hil\n  Scenario: SC-002 Start/Stop per unit                       # features/control.feature:12\n    Given the system is initialized                          # None\n    When I write holding register 40005 with value 1         # None\n    Then holding register 40021 should equal 1 within 100 ms # None\n\n  @pending @req-overload-reset @prd-5-functional @prd-10-api @reg-40009-40012 @hil\n  Scenario: SC-003 Overload Reset pulse semantics            # features/control.feature:18\n    Given the system is initialized                          # None\n    When I write holding register 40009 with value 1         # None\n    Then holding register 40009 should equal 0 within 100 ms # None\n\n  @pending @req-amplitude-clamp @prd-6-nfr @reg-40001-40004 @hil\n  Scenario Outline: SC-018 Amplitude clamping -- @1.1         # features/control.feature:31\n    Given the system is initialized                           # None\n    When I write holding register 40001 with value 10         # None\n    Then holding register 40001 should equal 20 within 100 ms # None\n\n  @pending @req-amplitude-clamp @prd-6-nfr @reg-40001-40004 @hil\n  Scenario Outline: SC-018 Amplitude clamping -- @1.2          # features/control.feature:32\n    Given the system is initialized                            # None\n    When I write holding register 40001 with value 105         # None\n    Then holding register 40001 should equal 100 within 100 ms # None\n\nFeature: Executive reporting # features/executive_reporting.feature:1\n\n  @pending @req-exec-report @hil\n  Scenario: SC-011 Executive report artifact                # features/executive_reporting.feature:6\n    Given the system is initialized                         # None\n    Then the CI pipeline generates a valid executive report # None\n\nFeature: Frequency measurement and lock status per unit # features/frequency_and_lock.feature:1\n  As an operator I can see frequency and lock status accurately per unit.\n  Background:   # features/frequency_and_lock.feature:4\n\n  @us-004\n  Scenario Outline: Frequency and lock reflected within 100 ms -- @1.1   # features/frequency_and_lock.feature:17\n    Given the HIL wrapper is connected and ready                         # None\n    And the DUT is powered and at safe defaults                          # None\n    Given unit 1 receives a frequency of 2000 Hz on the \u00f710 input        # None\n    And unit 1 lock input is set to 1                                    # None\n    Then within 100 ms holding register 40017 is approximately 2000 Hz   # None\n    And status flag bit2 for unit 1 equals 1                             # None\n\n  @us-004\n  Scenario Outline: Frequency and lock reflected within 100 ms -- @1.2   # features/frequency_and_lock.feature:18\n    Given the HIL wrapper is connected and ready                         # None\n    And the DUT is powered and at safe defaults                          # None\n    Given unit 1 receives a frequency of 0 Hz on the \u00f710 input           # None\n    And unit 1 lock input is set to 0                                    # None\n    Then within 100 ms holding register 40017 is approximately 0 Hz      # None\n    And status flag bit2 for unit 1 equals 0                             # None\n\nFeature: HAL Acceptance # features/hal.feature:1\n\n  @hal @implemented\n  Scenario: HAL basic acceptance         # features/hal.feature:3\n    Given the hardware is initialized    # None\n    When the HAL feature is exercised    # None\n    Then the expected result is observed # None\n\n  @pending\n  Scenario: HAL advanced acceptance (pending implementation)  # features/hal.feature:9\n    Given the hardware is initialized                         # None\n    When the advanced HAL feature is exercised                # None\n    Then the expected advanced result is observed             # None\n\nFeature: ADC Hardware Verification # features/hil_adc_verification.feature:1\n  As a firmware developer\n  I want to verify ADC functionality with known reference voltages\n  So that I can ensure power sensing and analog measurements work correctly\n  Background:   # features/hil_adc_verification.feature:6\n\n  @hil @hardware @adc\n  Scenario: POWER_SENSE_4 ADC channel verification    # features/hil_adc_verification.feature:12\n    Given the HIL framework is connected to ATmega32A # None\n    And the ADC subsystem is initialized              # None\n    And the ADC reference is set to 5.0V              # None\n    When I apply 0V to ADC channel \"POWER_SENSE_4\"    # None\n    Then the ADC reading should be approximately 0    # None\n    And the voltage should be approximately 0.0V      # None\n\n  @hil @hardware @adc\n  Scenario: POWER_SENSE_4 mid-scale verification        # features/hil_adc_verification.feature:18\n    Given the HIL framework is connected to ATmega32A   # None\n    And the ADC subsystem is initialized                # None\n    And the ADC reference is set to 5.0V                # None\n    When I apply 2.5V to ADC channel \"POWER_SENSE_4\"    # None\n    Then the ADC reading should be approximately 512    # None\n    And the voltage should be approximately 2.5V \u00b1 0.1V # None\n\n  @hil @hardware @adc\n  Scenario: POWER_SENSE_4 full-scale verification       # features/hil_adc_verification.feature:24\n    Given the HIL framework is connected to ATmega32A   # None\n    And the ADC subsystem is initialized                # None\n    And the ADC reference is set to 5.0V                # None\n    When I apply 5.0V to ADC channel \"POWER_SENSE_4\"    # None\n    Then the ADC reading should be approximately 1023   # None\n    And the voltage should be approximately 5.0V \u00b1 0.1V # None\n\n  @hil @hardware @adc\n  Scenario: Power measurement scaling verification             # features/hil_adc_verification.feature:30\n    Given the HIL framework is connected to ATmega32A          # None\n    And the ADC subsystem is initialized                       # None\n    And the ADC reference is set to 5.0V                       # None\n    Given the power measurement scaling is 5.44 mV/W           # None\n    When I simulate 100W power consumption                     # None\n    Then the ADC should read a voltage of approximately 0.544V # None\n    And the calculated power should be approximately 100W \u00b1 5W # None\n\n  @hil @hardware @adc\n  Scenario: ADC noise and stability                              # features/hil_adc_verification.feature:37\n    Given the HIL framework is connected to ATmega32A            # None\n    And the ADC subsystem is initialized                         # None\n    And the ADC reference is set to 5.0V                         # None\n    When I apply a stable 2.5V to ADC channel \"POWER_SENSE_4\"    # None\n    And I take 100 ADC readings over 10 seconds                  # None\n    Then the standard deviation should be less than 5 ADC counts # None\n    And all readings should be within \u00b120 ADC counts of the mean # None\n\n  @hil @hardware @adc\n  Scenario: Multiple ADC channel independence            # features/hil_adc_verification.feature:44\n    Given the HIL framework is connected to ATmega32A    # None\n    And the ADC subsystem is initialized                 # None\n    And the ADC reference is set to 5.0V                 # None\n    When I apply 1.0V to ADC channel \"POWER_SENSE_4\"     # None\n    And I apply 3.0V to another available ADC channel    # None\n    Then \"POWER_SENSE_4\" should read approximately 1.0V  # None\n    And the other channel should read approximately 3.0V # None\n    And neither channel should affect the other          # None\n\nFeature: Hardware Basic Connectivity # features/hil_basic_connectivity.feature:1\n  As a firmware developer\n  I want to verify basic hardware connectivity\n  So that I can ensure the HIL framework can communicate with the ATmega32A\n  Background:   # features/hil_basic_connectivity.feature:6\n\n  @hil @hardware @connectivity\n  Scenario: Power supply verification             # features/hil_basic_connectivity.feature:12\n    Given the Arduino test harness is connected   # None\n    And the ATmega32A target is powered           # None\n    And the HIL framework is initialized          # None\n    When I measure the power supply voltages      # None\n    Then the 24V input should be within tolerance # None\n    And the 5V rail should be 5.0V \u00b1 0.1V         # None\n    And the 3.3V rail should be 3.3V \u00b1 0.1V       # None\n\n  @hil @hardware @connectivity\n  Scenario: Programming interface verification                 # features/hil_basic_connectivity.feature:19\n    Given the Arduino test harness is connected                # None\n    And the ATmega32A target is powered                        # None\n    And the HIL framework is initialized                       # None\n    When I attempt to program the ATmega32A via Arduino as ISP # None\n    Then the programming should succeed                        # None\n    And the firmware version should be readable                # None\n    And the target should respond to commands                  # None\n\n  @hil @hardware @connectivity\n  Scenario: Serial communication establishment            # features/hil_basic_connectivity.feature:26\n    Given the Arduino test harness is connected           # None\n    And the ATmega32A target is powered                   # None\n    And the HIL framework is initialized                  # None\n    When I establish serial communication with the target # None\n    Then I should receive a valid response                # None\n    And the communication should be stable for 10 seconds # None\n\n  @hil @hardware @connectivity\n  Scenario: Arduino Test Harness ping test                 # features/hil_basic_connectivity.feature:32\n    Given the Arduino test harness is connected            # None\n    And the ATmega32A target is powered                    # None\n    And the HIL framework is initialized                   # None\n    When I send a ping command to the Arduino Test Harness # None\n    Then I should receive a PONG response                  # None\n    And the response time should be less than 100ms        # None\n\nFeature: GPIO Hardware Functionality # features/hil_gpio_functionality.feature:1\n  As a firmware developer\n  I want to verify GPIO pin control and monitoring\n  So that I can ensure sonicator interface pins work correctly\n  Background:   # features/hil_gpio_functionality.feature:6\n\n  @hil @hardware @gpio\n  Scenario: Digital output control - START_4 pin       # features/hil_gpio_functionality.feature:11\n    Given the HIL framework is connected to ATmega32A  # None\n    And the GPIO HAL is loaded on the target           # None\n    When I set pin \"START_4\" to HIGH via HIL framework # None\n    Then the pin voltage should be approximately 5.0V  # None\n    When I set pin \"START_4\" to LOW via HIL framework  # None\n    Then the pin voltage should be approximately 0.0V  # None\n\n  @hil @hardware @gpio\n  Scenario: Digital output control - RESET_4 pin       # features/hil_gpio_functionality.feature:18\n    Given the HIL framework is connected to ATmega32A  # None\n    And the GPIO HAL is loaded on the target           # None\n    When I set pin \"RESET_4\" to HIGH via HIL framework # None\n    Then the pin voltage should be approximately 5.0V  # None\n    When I set pin \"RESET_4\" to LOW via HIL framework  # None\n    Then the pin voltage should be approximately 0.0V  # None\n\n  @hil @hardware @gpio\n  Scenario: Digital input reading - OVERLOAD_4 pin                   # features/hil_gpio_functionality.feature:25\n    Given the HIL framework is connected to ATmega32A                # None\n    And the GPIO HAL is loaded on the target                         # None\n    Given pin \"OVERLOAD_4\" is configured as input with pull-up       # None\n    When the HIL framework applies 0V to pin \"OVERLOAD_4\" externally # None\n    Then reading pin \"OVERLOAD_4\" should return LOW                  # None\n    When the HIL framework disconnects the external connection       # None\n    Then reading pin \"OVERLOAD_4\" should return HIGH                 # None\n\n  @hil @hardware @gpio\n  Scenario: Digital input reading - FREQ_LOCK_4 pin        # features/hil_gpio_functionality.feature:33\n    Given the HIL framework is connected to ATmega32A      # None\n    And the GPIO HAL is loaded on the target               # None\n    Given pin \"FREQ_LOCK_4\" is configured as input         # None\n    When the HIL framework applies 5V to pin \"FREQ_LOCK_4\" # None\n    Then reading pin \"FREQ_LOCK_4\" should return HIGH      # None\n    When the HIL framework applies 0V to pin \"FREQ_LOCK_4\" # None\n    Then reading pin \"FREQ_LOCK_4\" should return LOW       # None\n\n  @hil @hardware @gpio\n  Scenario: Pin state persistence                     # features/hil_gpio_functionality.feature:41\n    Given the HIL framework is connected to ATmega32A # None\n    And the GPIO HAL is loaded on the target          # None\n    When I set pin \"START_4\" to HIGH                  # None\n    And I set pin \"RESET_4\" to LOW                    # None\n    And I wait for 5 seconds                          # None\n    Then pin \"START_4\" should still be HIGH           # None\n    And pin \"RESET_4\" should still be LOW             # None\n\n  @hil @hardware @gpio\n  Scenario: Status LED control                            # features/hil_gpio_functionality.feature:49\n    Given the HIL framework is connected to ATmega32A     # None\n    And the GPIO HAL is loaded on the target              # None\n    When I set pin \"STATUS_LED\" to HIGH                   # None\n    Then the status LED should be visible on the hardware # None\n    When I set pin \"STATUS_LED\" to LOW                    # None\n    Then the status LED should be off                     # None\n\nFeature: MODBUS RTU Communication Hardware Validation # features/hil_modbus_communication.feature:1\n  As a PLC integration engineer\n  I want to verify MODBUS RTU communication with real hardware\n  So that I can ensure reliable industrial automation integration\n  Background:   # features/hil_modbus_communication.feature:6\n\n  @hil @modbus @hardware\n  Scenario: Read System Status Registers                   # features/hil_modbus_communication.feature:13\n    Given the ATmega32A is programmed with MODBUS firmware # None\n    And the HIL framework is connected                     # None\n    And the MODBUS slave ID is set to 2                    # None\n    And communication is established at 115200 baud        # None\n    When I read MODBUS register 0x0000 (system status)     # None\n    Then the register value should be valid                # None\n    And the response time should be less than 100ms        # None\n    And the CRC should be correct                          # None\n\n  @hil @modbus @hardware\n  Scenario: Write and Verify Control Register                      # features/hil_modbus_communication.feature:20\n    Given the ATmega32A is programmed with MODBUS firmware         # None\n    And the HIL framework is connected                             # None\n    And the MODBUS slave ID is set to 2                            # None\n    And communication is established at 115200 baud                # None\n    When I write value 1 to MODBUS register 0x0010 (global enable) # None\n    Then reading register 0x0010 should return value 1             # None\n    And the register change should be reflected within 100ms       # None\n    And the system status should update accordingly                # None\n\n  @hil @modbus @hardware\n  Scenario: Communication Fault Detection                  # features/hil_modbus_communication.feature:27\n    Given the ATmega32A is programmed with MODBUS firmware # None\n    And the HIL framework is connected                     # None\n    And the MODBUS slave ID is set to 2                    # None\n    And communication is established at 115200 baud        # None\n    Given the MODBUS communication is established          # None\n    When I disconnect the communication cable              # None\n    And wait for 2 seconds                                 # None\n    Then the system should detect communication fault      # None\n    And enter failsafe mode per requirements               # None\n\n  @hil @modbus @hardware\n  Scenario: Multiple register read operation                  # features/hil_modbus_communication.feature:35\n    Given the ATmega32A is programmed with MODBUS firmware    # None\n    And the HIL framework is connected                        # None\n    And the MODBUS slave ID is set to 2                       # None\n    And communication is established at 115200 baud           # None\n    When I read MODBUS registers 0x0000 to 0x0003 in sequence # None\n    Then all reads should succeed                             # None\n    And each response time should be less than 100ms          # None\n    And all CRC values should be correct                      # None\n\n  @hil @modbus @hardware\n  Scenario: Register write and immediate readback          # features/hil_modbus_communication.feature:42\n    Given the ATmega32A is programmed with MODBUS firmware # None\n    And the HIL framework is connected                     # None\n    And the MODBUS slave ID is set to 2                    # None\n    And communication is established at 115200 baud        # None\n    When I write value 0x1234 to MODBUS register 0x0100    # None\n    And immediately read MODBUS register 0x0100            # None\n    Then the read value should be 0x1234                   # None\n    And the total operation time should be less than 200ms # None\n\n  @hil @modbus @hardware\n  Scenario: Invalid register access handling                        # features/hil_modbus_communication.feature:49\n    Given the ATmega32A is programmed with MODBUS firmware          # None\n    And the HIL framework is connected                              # None\n    And the MODBUS slave ID is set to 2                             # None\n    And communication is established at 115200 baud                 # None\n    When I attempt to read MODBUS register 0xFFFF (invalid address) # None\n    Then I should receive a MODBUS exception response               # None\n    And the exception code should indicate illegal address          # None\n\n  @hil @modbus @hardware\n  Scenario: CRC error handling                             # features/hil_modbus_communication.feature:55\n    Given the ATmega32A is programmed with MODBUS firmware # None\n    And the HIL framework is connected                     # None\n    And the MODBUS slave ID is set to 2                    # None\n    And communication is established at 115200 baud        # None\n    When I send a MODBUS request with invalid CRC          # None\n    Then the slave should not respond                      # None\n    And no register values should change                   # None\n    When I send the same request with valid CRC            # None\n    Then the slave should respond correctly                # None\n\n  @hil @modbus @hardware\n  Scenario: Communication timeout handling                         # features/hil_modbus_communication.feature:63\n    Given the ATmega32A is programmed with MODBUS firmware         # None\n    And the HIL framework is connected                             # None\n    And the MODBUS slave ID is set to 2                            # None\n    And communication is established at 115200 baud                # None\n    When I stop sending MODBUS requests for 5 seconds              # None\n    Then the communication fault flag should be set                # None\n    When I resume MODBUS communication                             # None\n    Then the communication fault flag should clear within 1 second # None\n\n  @hil @modbus @hardware\n  Scenario: Sonicator control via MODBUS                               # features/hil_modbus_communication.feature:70\n    Given the ATmega32A is programmed with MODBUS firmware             # None\n    And the HIL framework is connected                                 # None\n    And the MODBUS slave ID is set to 2                                # None\n    And communication is established at 115200 baud                    # None\n    When I write value 1 to MODBUS register 0x0160 (sonicator 4 start) # None\n    Then pin \"START_4\" should go HIGH                                  # None\n    When I write value 0 to MODBUS register 0x0160                     # None\n    Then pin \"START_4\" should go LOW                                   # None\n    And the operation should complete within 50ms                      # None\n\nFeature: Power Supply and Electrical Verification # features/hil_power_verification.feature:1\n  As a hardware engineer\n  I want to verify power supply voltages and electrical characteristics\n  So that I can ensure the system operates within specifications\n  Background:   # features/hil_power_verification.feature:6\n\n  @hil @hardware @power\n  Scenario: Input power supply verification               # features/hil_power_verification.feature:12\n    Given the HIL framework is connected                  # None\n    And the power supply is enabled                       # None\n    And the ATmega32A target is powered                   # None\n    When I measure the input voltage                      # None\n    Then the 24V input should be 24.0V \u00b1 0.5V             # None\n    And the input current should be within expected range # None\n\n  @hil @hardware @power\n  Scenario: Regulated power rail verification                    # features/hil_power_verification.feature:18\n    Given the HIL framework is connected                         # None\n    And the power supply is enabled                              # None\n    And the ATmega32A target is powered                          # None\n    When I measure the regulated power rails                     # None\n    Then the 5V rail should be 5.0V \u00b1 0.1V                       # None\n    And the 3.3V rail should be 3.3V \u00b1 0.1V if present           # None\n    And the ripple voltage should be less than 50mV peak-to-peak # None\n\n  @hil @hardware @power\n  Scenario: Power supply load regulation                              # features/hil_power_verification.feature:25\n    Given the HIL framework is connected                              # None\n    And the power supply is enabled                                   # None\n    And the ATmega32A target is powered                               # None\n    When I apply varying loads to the 5V rail                         # None\n    Then the voltage should remain 5.0V \u00b1 0.1V                        # None\n    And the regulation should be maintained under all load conditions # None\n\n  @hil @hardware @power\n  Scenario: Crystal oscillator verification         # features/hil_power_verification.feature:31\n    Given the HIL framework is connected            # None\n    And the power supply is enabled                 # None\n    And the ATmega32A target is powered             # None\n    When I measure the crystal oscillator frequency # None\n    Then the frequency should be 16.000MHz \u00b1 0.01%  # None\n    And the crystal should be stable and running    # None\n\n  @hil @hardware @power\n  Scenario: Power-on sequence verification                    # features/hil_power_verification.feature:37\n    Given the HIL framework is connected                      # None\n    And the power supply is enabled                           # None\n    And the ATmega32A target is powered                       # None\n    When I power cycle the system                             # None\n    Then the power rails should come up in correct sequence   # None\n    And the ATmega32A should start executing within 2 seconds # None\n    And all GPIO pins should be in their default states       # None\n\n  @hil @hardware @power\n  Scenario: Brown-out detection verification                              # features/hil_power_verification.feature:44\n    Given the HIL framework is connected                                  # None\n    And the power supply is enabled                                       # None\n    And the ATmega32A target is powered                                   # None\n    When I gradually reduce the input voltage                             # None\n    Then the brown-out detector should trigger at the specified threshold # None\n    And the system should reset cleanly                                   # None\n    When the voltage is restored                                          # None\n    Then the system should restart normally                               # None\n\nFeature: PWM Generation Hardware Verification # features/hil_pwm_generation.feature:1\n  As a firmware developer\n  I want to verify PWM output generation and measurement\n  So that I can ensure amplitude control signals work correctly\n  Background:   # features/hil_pwm_generation.feature:6\n\n  @hil @hardware @pwm\n  Scenario: Basic PWM output generation                                # features/hil_pwm_generation.feature:12\n    Given the HIL framework is connected to ATmega32A                  # None\n    And the PWM subsystem is initialized                               # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output               # None\n    When I set PWM on pin \"AMPLITUDE_ALL\" to 50% duty cycle at 1kHz    # None\n    Then the HIL framework should measure approximately 50% duty cycle # None\n    And the frequency should be approximately 1000Hz \u00b1 10Hz            # None\n\n  @hil @hardware @pwm\n  Scenario: PWM duty cycle variation                        # features/hil_pwm_generation.feature:18\n    Given the HIL framework is connected to ATmega32A       # None\n    And the PWM subsystem is initialized                    # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output    # None\n    When I set PWM duty cycle to 25% on pin \"AMPLITUDE_ALL\" # None\n    Then the measured duty cycle should be 25% \u00b1 2%         # None\n    When I set PWM duty cycle to 75% on pin \"AMPLITUDE_ALL\" # None\n    Then the measured duty cycle should be 75% \u00b1 2%         # None\n\n  @hil @hardware @pwm\n  Scenario: PWM frequency accuracy                            # features/hil_pwm_generation.feature:25\n    Given the HIL framework is connected to ATmega32A         # None\n    And the PWM subsystem is initialized                      # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output      # None\n    When I set PWM frequency to 500Hz on pin \"AMPLITUDE_ALL\"  # None\n    Then the measured frequency should be 500Hz \u00b1 5Hz         # None\n    When I set PWM frequency to 2000Hz on pin \"AMPLITUDE_ALL\" # None\n    Then the measured frequency should be 2000Hz \u00b1 20Hz       # None\n\n  @hil @hardware @pwm\n  Scenario: PWM voltage levels                                   # features/hil_pwm_generation.feature:32\n    Given the HIL framework is connected to ATmega32A            # None\n    And the PWM subsystem is initialized                         # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output         # None\n    When I set PWM to 0% duty cycle on pin \"AMPLITUDE_ALL\"       # None\n    Then the average voltage should be approximately 0V          # None\n    When I set PWM to 100% duty cycle on pin \"AMPLITUDE_ALL\"     # None\n    Then the average voltage should be approximately 5V          # None\n    When I set PWM to 50% duty cycle on pin \"AMPLITUDE_ALL\"      # None\n    Then the average voltage should be approximately 2.5V \u00b1 0.2V # None\n\n  @hil @hardware @pwm\n  Scenario: PWM signal stability                                    # features/hil_pwm_generation.feature:41\n    Given the HIL framework is connected to ATmega32A               # None\n    And the PWM subsystem is initialized                            # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output            # None\n    When I set PWM to 60% duty cycle at 1kHz on pin \"AMPLITUDE_ALL\" # None\n    And I measure PWM for 10 seconds continuously                   # None\n    Then the duty cycle should remain stable within \u00b11%             # None\n    And the frequency should remain stable within \u00b15Hz              # None\n\n  @hil @hardware @pwm\n  Scenario: PWM disable and enable                                 # features/hil_pwm_generation.feature:48\n    Given the HIL framework is connected to ATmega32A              # None\n    And the PWM subsystem is initialized                           # None\n    And pin \"AMPLITUDE_ALL\" is configured for PWM output           # None\n    When PWM is enabled on pin \"AMPLITUDE_ALL\" with 40% duty cycle # None\n    Then I should measure PWM signal                               # None\n    When I disable PWM on pin \"AMPLITUDE_ALL\"                      # None\n    Then the pin should be in a static state                       # None\n    When I re-enable PWM with the same settings                    # None\n    Then I should measure the same PWM signal again                # None\n\n@hil @smoke\nFeature: HIL Smoke Test # features/hil_smoke.feature:2\n  Verify HIL wrapper connectivity and basic communication.\n  Background:   # features/hil_smoke.feature:5\n\n  Scenario: HIL-001 Wrapper responds to PING           # features/hil_smoke.feature:8\n    Given the HIL wrapper is connected and ready       # None\n    Then the harness sanity check passes               # None\n    And the serial device is available for the harness # None\n\nFeature: HMI/PLC integration # features/hmi_integration.feature:1\n\n  @pending @req-hmi @hil\n  Scenario: SC-010 HMI contract adherence (4xxxx convention)  # features/hmi_integration.feature:6\n    Given the system is initialized                           # None\n    When I write holding register 40001 with value 80         # None\n    Then holding register 40001 should equal 80 within 100 ms # None\n\n  @pending @req-hmi-addressing @hil\n  Scenario: SC-024 HMI addressing examples                   # features/hmi_integration.feature:12\n    Given the system is initialized                          # None\n    When I write holding register 40005 with value 1         # None\n    Then holding register 40021 should equal 1 within 100 ms # None\n\nFeature: MODBUS protocol behaviors # features/modbus.feature:1\n\n  @pending @req-fc16 @hil\n  Scenario: SC-020 FC16 multiple write boundary cases         # features/modbus.feature:6\n    Given the system is initialized                           # None\n    When I write holding register 40001 with value 50         # None\n    Then holding register 40001 should equal 50 within 100 ms # None\n\n  @req-illegal-address @hil\n  Scenario: SC-021 Illegal address handling                  # features/modbus.feature:12\n    Given the system is initialized                          # None\n    When I write holding register 49999 with value 1         # None\n    Then holding register 49999 should equal 0 within 100 ms # None\n\n  @req-slave-id @hil\n  Scenario: SC-022 Slave ID configuration                    # features/modbus.feature:18\n    Given the system is initialized                          # None\n    When I write holding register 40002 with value 2         # None\n    Then holding register 40002 should equal 2 within 100 ms # None\n\n  @req-crc @hil\n  Scenario: SC-023 CRC error handling  # features/modbus.feature:24\n    Given the system is initialized    # None\n    Then corrupted frames are rejected # None\n\nFeature: Monitoring via MODBUS # features/monitoring.feature:1\n\n  @pending @req-power @prd-10-api @reg-40013-40016 @hil\n  Scenario: SC-004 Power monitoring scaling                    # features/monitoring.feature:6\n    Given the system is initialized                            # None\n    When I simulate power reading of 100                       # None\n    Then holding register 40013 should equal 100 within 100 ms # None\n\n  @req-frequency @prd-10-api @reg-40017-40020 @hil\n  Scenario: SC-005 Frequency monitoring                          # features/monitoring.feature:12\n    Given the system is initialized                              # None\n    When I simulate frequency reading of 20000                   # None\n    Then holding register 40017 should equal 20000 within 100 ms # None\n\n  @req-status-flags @prd-10-api @reg-40021-40024 @hil\n  Scenario: SC-006 Status flags            # features/monitoring.feature:18\n    Given the system is initialized        # None\n    When I simulate starting sonicator 1   # None\n    Then status flag bit 0 for unit 1 is 1 # None\n\n  @req-runtimes @reg-40027-40030 @hil\n  Scenario: SC-015 Per-unit runtimes                          # features/monitoring.feature:24\n    Given the system is initialized                           # None\n    When I simulate starting sonicator 1                      # None\n    Then holding register 40027 should equal 5 within 1000 ms # None\n\n  @req-overload-counts @reg-40031-40034 @hil\n  Scenario: SC-016 Overload counts                           # features/monitoring.feature:30\n    Given the system is initialized                          # None\n    When I simulate overload on sonicator 1                  # None\n    Then holding register 40031 should equal 1 within 200 ms # None\n\n  @req-freq-lock @hil\n  Scenario: SC-019 Frequency lock behavior        # features/monitoring.feature:36\n    Given the system is initialized               # None\n    When I simulate frequency lock on sonicator 1 # None\n    Then status flag bit 2 for unit 1 is 1        # None\n\nFeature: Overload detection and reset per unit # features/overload_reset.feature:1\n  As an operator I can see overload per unit and clear it safely.\n  Background:   # features/overload_reset.feature:4\n\n  @us-002\n  Scenario Outline: Overload flag reflects and reset behavior is correct -- @1.1      # features/overload_reset.feature:17\n    Given the HIL wrapper is connected and ready                                      # None\n    And the DUT is powered and at safe defaults                                       # None\n    Given unit 1 overload input is set to 1                                           # None\n    When I write 1 to holding register 40009 to request overload reset                # None\n    Then within 100 ms the overload flag bit1 for unit 1 equals 1                     # None\n    And starting the unit via register 40005 yields behavior per spec when overload=1 # None\n\n  @us-002\n  Scenario Outline: Overload flag reflects and reset behavior is correct -- @1.2      # features/overload_reset.feature:18\n    Given the HIL wrapper is connected and ready                                      # None\n    And the DUT is powered and at safe defaults                                       # None\n    Given unit 1 overload input is set to 0                                           # None\n    When I write 1 to holding register 40009 to request overload reset                # None\n    Then within 100 ms the overload flag bit1 for unit 1 equals 0                     # None\n    And starting the unit via register 40005 yields behavior per spec when overload=0 # None\n\nFeature: Production Validation Testing # features/production_validation.feature:1\n  As a quality assurance engineer\n  I want to validate the Multi-Sonicator I/O Controller for production deployment\n  So that I can ensure it meets all industrial requirements and specifications\n  Background:   # features/production_validation.feature:6\n\n  @production @validation @critical\n  Scenario: Factory acceptance test sequence                                # features/production_validation.feature:12\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is in factory test mode                                # None\n    When I execute the complete factory test sequence                       # None\n    Then all hardware interfaces should pass connectivity tests             # None\n    And all sonicator control circuits should pass functional tests         # None\n    And MODBUS communication should pass protocol compliance tests          # None\n    And power supply regulation should pass load tests                      # None\n    And all safety systems should pass verification tests                   # None\n    And the system should generate a passing factory test report            # None\n\n  @production @validation @environmental\n  Scenario: Environmental stress testing                                    # features/production_validation.feature:23\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for environmental testing                # None\n    When I subject the system to temperature cycling from -10\u00b0C to +60\u00b0C    # None\n    And I subject the system to humidity variations from 10% to 90% RH      # None\n    And I subject the system to vibration testing per industrial standards  # None\n    Then the system should maintain full functionality throughout           # None\n    And no performance degradation should occur                             # None\n    And all connections should remain secure                                # None\n    And the enclosure should maintain its integrity                         # None\n\n  @production @validation @electrical\n  Scenario: Electrical safety and compliance validation                     # features/production_validation.feature:34\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for electrical testing                   # None\n    When I perform insulation resistance testing                            # None\n    And I perform ground continuity testing                                 # None\n    And I perform surge immunity testing                                    # None\n    And I perform EMC/EMI compliance testing                                # None\n    Then all tests should pass industrial safety standards                  # None\n    And the system should meet CE marking requirements                      # None\n    And no electrical hazards should be present                             # None\n    And EMC emissions should be within acceptable limits                    # None\n\n  @production @validation @reliability\n  Scenario: Long-term reliability testing                                   # features/production_validation.feature:46\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for reliability testing                  # None\n    When I run the system continuously for 168 hours (1 week)               # None\n    And all sonicators cycle through various operating conditions           # None\n    And I monitor all system parameters continuously                        # None\n    Then no failures or degradation should occur                            # None\n    And all telemetry should remain accurate                                # None\n    And no memory leaks or resource exhaustion should occur                 # None\n    And the system should maintain stable operation                         # None\n\n  @production @validation @performance\n  Scenario: Performance specification validation                            # features/production_validation.feature:57\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for performance testing                  # None\n    When I measure command response times under various loads               # None\n    Then start/stop commands should complete within 200ms                   # None\n    And amplitude changes should be reflected within 100ms                  # None\n    And MODBUS register updates should occur within 100ms                   # None\n    And telemetry updates should occur at minimum 10Hz                      # None\n    And power measurement accuracy should be within \u00b12%                     # None\n    And frequency measurement accuracy should be within \u00b11%                 # None\n\n  @production @validation @safety\n  Scenario: Safety system validation                                        # features/production_validation.feature:68\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for safety testing                       # None\n    When I test the emergency stop functionality                            # None\n    Then all sonicators should stop within 50ms                             # None\n    When I test overload protection for each sonicator                      # None\n    Then overload conditions should be detected within 100ms                # None\n    When I test watchdog timer functionality                                # None\n    Then system resets should occur within specified timeouts               # None\n    When I test communication fault detection                               # None\n    Then faults should be detected and handled appropriately                # None\n\n  @production @validation @modbus\n  Scenario: MODBUS protocol compliance validation                           # features/production_validation.feature:80\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is configured for MODBUS testing                       # None\n    When I test all supported MODBUS function codes                         # None\n    Then function code 03 (Read Holding Registers) should work correctly    # None\n    And function code 06 (Write Single Register) should work correctly      # None\n    And function code 16 (Write Multiple Registers) should work correctly   # None\n    When I test error handling and exception responses                      # None\n    Then illegal address exceptions should be handled correctly             # None\n    And illegal data value exceptions should be handled correctly           # None\n    And CRC errors should be detected and rejected                          # None\n\n  @production @validation @interoperability\n  Scenario: PLC integration validation                                      # features/production_validation.feature:92\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is connected to a Velocio 1630c PLC                    # None\n    When I configure the PLC for multi-sonicator operation                  # None\n    Then the PLC should successfully communicate with the controller        # None\n    And all register mappings should work correctly                         # None\n    And HMI integration should function properly                            # None\n    And alarm handling should work as specified                             # None\n    And data logging should capture all required parameters                 # None\n\n  @production @validation @manufacturing\n  Scenario: Manufacturing test automation                                   # features/production_validation.feature:102\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is on the manufacturing test fixture                   # None\n    When I execute the automated manufacturing test sequence                # None\n    Then all PCB traces should pass continuity testing                      # None\n    And all component values should be within tolerance                     # None\n    And all solder joints should pass inspection                            # None\n    And firmware programming should complete successfully                   # None\n    And calibration should be performed and verified                        # None\n    And the system should receive a unique serial number                    # None\n\n  @production @validation @documentation\n  Scenario: Documentation and traceability validation                       # features/production_validation.feature:113\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is ready for shipment                                  # None\n    When I verify all required documentation                                # None\n    Then the user manual should be complete and accurate                    # None\n    And installation instructions should be clear and correct               # None\n    And maintenance procedures should be documented                         # None\n    And troubleshooting guides should be comprehensive                      # None\n    And all certifications should be included                               # None\n    And traceability records should be complete                             # None\n\n  @pending @production @validation @field-upgrade\n  Scenario: Field upgrade capability validation                             # features/production_validation.feature:124\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system is deployed in the field                               # None\n    When a firmware update becomes available                                # None\n    Then the system should support ISP programming                          # None\n    And the update process should be documented                             # None\n    And rollback procedures should be available                             # None\n    And configuration should be preserved during updates                    # None\n    And the system should validate firmware integrity                       # None\n\n  @pending @production @validation @remote-monitoring\n  Scenario: Remote monitoring and diagnostics                               # features/production_validation.feature:134\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system supports remote monitoring                             # None\n    When I connect to the system remotely                                   # None\n    Then I should be able to read all system parameters                     # None\n    And I should be able to view system status and alarms                   # None\n    And I should be able to download diagnostic logs                        # None\n    And I should be able to perform basic troubleshooting                   # None\n    And all remote access should be secure and authenticated                # None\n\n  @pending @production @validation @predictive-maintenance\n  Scenario: Predictive maintenance capabilities                             # features/production_validation.feature:144\n    Given the Multi-Sonicator I/O Controller is in production configuration # None\n    And all hardware components are properly installed                      # None\n    And the system has passed initial factory tests                         # None\n    Given the system has been operating for extended periods                # None\n    When I analyze historical performance data                              # None\n    Then the system should identify wear patterns                           # None\n    And predict component replacement schedules                             # None\n    And recommend maintenance actions                                       # None\n    And provide early warning of potential failures                         # None\n    And optimize maintenance intervals based on usage patterns              # None\n\nFeature: Regulatory Compliance and Standards Validation # features/regulatory_compliance.feature:1\n  As a compliance officer\n  I want to validate that the Multi-Sonicator I/O Controller meets all regulatory requirements\n  So that the system can be deployed in regulated industrial environments\n  Background:   # features/regulatory_compliance.feature:6\n\n  @compliance @regulatory @critical\n  Scenario: FDA 21 CFR Part 11 compliance validation                              # features/regulatory_compliance.feature:12\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is configured for pharmaceutical manufacturing               # None\n    When I test electronic record keeping capabilities                            # None\n    Then all process data should be stored with digital signatures                # None\n    And audit trails should be maintained for all system changes                  # None\n    And user access should be controlled with unique identifications              # None\n    And data integrity should be maintained throughout the lifecycle              # None\n    And electronic signatures should be legally binding                           # None\n    And the system should prevent unauthorized data modification                  # None\n\n  @compliance @regulatory @critical\n  Scenario: ISO 9001 quality management compliance                                # features/regulatory_compliance.feature:23\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is part of a quality management system                       # None\n    When I validate quality control processes                                     # None\n    Then all process parameters should be documented and controlled               # None\n    And calibration records should be maintained for all instruments              # None\n    And corrective and preventive actions should be tracked                       # None\n    And management review processes should be supported                           # None\n    And continuous improvement should be facilitated                              # None\n    And customer satisfaction should be measurable                                # None\n\n  @compliance @regulatory @safety\n  Scenario: IEC 61508 functional safety compliance                                # features/regulatory_compliance.feature:34\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system includes safety-critical functions                           # None\n    When I validate functional safety requirements                                # None\n    Then safety integrity levels should be properly classified                    # None\n    And systematic failures should be prevented through design                    # None\n    And random hardware failures should be controlled                             # None\n    And safety lifecycle processes should be followed                             # None\n    And verification and validation should be documented                          # None\n    And functional safety management should be implemented                        # None\n\n  @compliance @regulatory @electrical\n  Scenario: IEC 61010 electrical safety compliance                                # features/regulatory_compliance.feature:45\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is used in laboratory/industrial environments                # None\n    When I test electrical safety requirements                                    # None\n    Then protection against electric shock should be verified                     # None\n    And protection against energy hazards should be confirmed                     # None\n    And protection against fire hazards should be validated                       # None\n    And protection against mechanical hazards should be tested                    # None\n    And protection against chemical hazards should be assessed                    # None\n    And environmental requirements should be met                                  # None\n\n  @compliance @regulatory @emc\n  Scenario: EMC directive compliance (2014/30/EU)                                 # features/regulatory_compliance.feature:56\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system must meet electromagnetic compatibility requirements         # None\n    When I perform EMC testing                                                    # None\n    Then electromagnetic emissions should be within prescribed limits             # None\n    And electromagnetic immunity should meet minimum requirements                 # None\n    And the system should not interfere with other equipment                      # None\n    And the system should operate correctly in its electromagnetic environment    # None\n    And CE marking requirements should be satisfied                               # None\n    And technical documentation should be complete                                # None\n\n  @compliance @regulatory @environmental\n  Scenario: RoHS directive compliance (2011/65/EU)                                # features/regulatory_compliance.feature:67\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system must comply with hazardous substance restrictions            # None\n    When I validate material composition                                          # None\n    Then lead content should be below 0.1% by weight                              # None\n    And mercury content should be below 0.1% by weight                            # None\n    And cadmium content should be below 0.01% by weight                           # None\n    And hexavalent chromium should be below 0.1% by weight                        # None\n    And PBB/PBDE flame retardants should be below 0.1% by weight                  # None\n    And supplier declarations should be documented                                # None\n\n  @compliance @regulatory @data-protection\n  Scenario: GDPR data protection compliance                                       # features/regulatory_compliance.feature:78\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system processes personal data                                      # None\n    When I validate data protection measures                                      # None\n    Then data processing should have a lawful basis                               # None\n    And data subjects should have appropriate rights                              # None\n    And data should be processed transparently                                    # None\n    And data minimization principles should be followed                           # None\n    And data accuracy should be maintained                                        # None\n    And storage limitation should be respected                                    # None\n    And appropriate security measures should be implemented                       # None\n\n  @compliance @regulatory @cybersecurity\n  Scenario: IEC 62443 industrial cybersecurity compliance                         # features/regulatory_compliance.feature:90\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is connected to industrial networks                          # None\n    When I validate cybersecurity requirements                                    # None\n    Then security levels should be properly classified                            # None\n    And access control should be implemented appropriately                        # None\n    And data integrity should be protected                                        # None\n    And availability should be maintained                                         # None\n    And confidentiality should be preserved where required                        # None\n    And security monitoring should be in place                                    # None\n\n  @compliance @regulatory @calibration\n  Scenario: ISO/IEC 17025 calibration compliance                                  # features/regulatory_compliance.feature:101\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system includes measurement instruments                             # None\n    When I validate calibration processes                                         # None\n    Then measurement traceability should be established                           # None\n    And calibration intervals should be appropriate                               # None\n    And calibration procedures should be documented                               # None\n    And measurement uncertainty should be evaluated                               # None\n    And calibration records should be maintained                                  # None\n    And competence of calibration personnel should be demonstrated                # None\n\n  @compliance @regulatory @documentation\n  Scenario: Technical documentation compliance                                    # features/regulatory_compliance.feature:112\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system requires comprehensive documentation                         # None\n    When I validate documentation completeness                                    # None\n    Then user manuals should be complete and accurate                             # None\n    And installation instructions should be clear                                 # None\n    And maintenance procedures should be documented                               # None\n    And safety information should be prominent                                    # None\n    And regulatory declarations should be included                                # None\n    And version control should be maintained                                      # None\n\n  @pending @compliance @regulatory @medical\n  Scenario: Medical device regulation compliance (MDR 2017/745)                   # features/regulatory_compliance.feature:123\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is used in medical device manufacturing                      # None\n    When I validate medical device requirements                                   # None\n    Then risk management should follow ISO 14971                                  # None\n    And quality management should follow ISO 13485                                # None\n    And clinical evaluation should be documented                                  # None\n    And post-market surveillance should be planned                                # None\n    And unique device identification should be implemented                        # None\n    And authorized representative should be designated                            # None\n\n  @pending @compliance @regulatory @export\n  Scenario: Export control compliance                                             # features/regulatory_compliance.feature:134\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system may be exported internationally                              # None\n    When I validate export control requirements                                   # None\n    Then export classification should be determined                               # None\n    And dual-use technology should be identified                                  # None\n    And export licenses should be obtained where required                         # None\n    And end-user verification should be performed                                 # None\n    And re-export restrictions should be documented                               # None\n    And compliance monitoring should be maintained                                # None\n\n  @pending @compliance @regulatory @environmental-management\n  Scenario: ISO 14001 environmental management compliance                         # features/regulatory_compliance.feature:145\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system is part of an environmental management system                # None\n    When I validate environmental requirements                                    # None\n    Then environmental aspects should be identified                               # None\n    And environmental impacts should be evaluated                                 # None\n    And environmental objectives should be established                            # None\n    And environmental performance should be monitored                             # None\n    And legal compliance should be ensured                                        # None\n    And continual improvement should be demonstrated                              # None\n\n  @pending @compliance @regulatory @energy-efficiency\n  Scenario: Energy efficiency directive compliance                                # features/regulatory_compliance.feature:156\n    Given the Multi-Sonicator I/O Controller is configured for compliance testing # None\n    And all required documentation is available                                   # None\n    And the system is in a controlled test environment                            # None\n    Given the system must meet energy efficiency requirements                     # None\n    When I validate energy performance                                            # None\n    Then energy consumption should be measured and reported                       # None\n    And energy efficiency should meet minimum standards                           # None\n    And energy management systems should be implemented                           # None\n    And energy audits should be performed regularly                               # None\n    And energy saving opportunities should be identified                          # None\n    And energy performance indicators should be tracked                           # None\n\nFeature: Safety # features/safety.feature:1\n\n  @pending @req-watchdog-docs\n  Scenario: SC-012 Watchdog policy is documented      # features/safety.feature:6\n    Given the system is initialized                   # None\n    Then the watchdog policy documentation is present # None\n\n  @req-estop @hil\n  Scenario: SC-014 Emergency stop register behavior         # features/safety.feature:11\n    Given the system is initialized                         # None\n    When I trigger emergency stop                           # None\n    Then holding register 40026 should equal 1 within 50 ms # None\n\n@smoke @hil\nFeature: Smoke # features/smoke.feature:2\n  Verify BDD harness and Arduino Test Wrapper can execute a passing test.\n  Scenario: SMK-001 Harness runs a passing step           # features/smoke.feature:5\n    Given the HIL test harness is connected               # None\n    Then the harness sanity check passes                  # None\n    And the Arduino Test Wrapper is available for testing # None\n\n  @smoke @web-ui @acceptance\n  Scenario: SMK-002 Web UI Smoke Acceptance Test       # features/smoke.feature:11\n    Given the web UI backend is running and healthy    # None\n    And the web UI frontend is accessible              # None\n    When I verify all Sonicator #4 pins are accessible # None\n    Then all pin control APIs respond correctly        # None\n    And the frequency generation system is functional  # None\n    And the PWM monitoring system is operational       # None\n    And the theme toggle system works correctly        # None\n\nFeature: Sonicator Acceptance # features/sonicator.feature:1\n\n  @sonicator @implemented\n  Scenario: Sonicator basic acceptance      # features/sonicator.feature:3\n    Given the hardware is initialized       # None\n    When the sonicator feature is exercised # None\n    Then the expected result is observed    # None\n\n  @pending\n  Scenario: Sonicator advanced acceptance (pending implementation)  # features/sonicator.feature:9\n    Given the hardware is initialized                               # None\n    When the advanced sonicator feature is exercised                # None\n    Then the expected advanced result is observed                   # None\n\nFeature: Start and stop a single sonicator # features/start_stop.feature:1\n  As an operator I can start/stop any unit and see status reflected promptly.\n  Background:   # features/start_stop.feature:4\n\n  @smoke @us-001\n  Scenario Outline: Start/Stop reflects in status and system count/mask within 100 ms -- @1.1   # features/start_stop.feature:16\n    Given the HIL wrapper is connected and ready                                                # None\n    And the DUT is powered and at safe defaults                                                 # None\n    When I write 1 to holding register 40005                                                    # None\n    Then within 100 ms the status flag bit0 for unit 1 equals 1                                 # None\n    And Active Sonicator Count and Mask reflect the running units                               # None\n\n  @smoke @us-001\n  Scenario Outline: Start/Stop reflects in status and system count/mask within 100 ms -- @1.2   # features/start_stop.feature:17\n    Given the HIL wrapper is connected and ready                                                # None\n    And the DUT is powered and at safe defaults                                                 # None\n    When I write 0 to holding register 40005                                                    # None\n    Then within 100 ms the status flag bit0 for unit 1 equals 0                                 # None\n    And Active Sonicator Count and Mask reflect the running units                               # None\n\n  @smoke @us-001\n  Scenario Outline: Start/Stop reflects in status and system count/mask within 100 ms -- @1.3   # features/start_stop.feature:18\n    Given the HIL wrapper is connected and ready                                                # None\n    And the DUT is powered and at safe defaults                                                 # None\n    When I write 1 to holding register 40006                                                    # None\n    Then within 100 ms the status flag bit0 for unit 2 equals 1                                 # None\n    And Active Sonicator Count and Mask reflect the running units                               # None\n\n  @smoke @us-001\n  Scenario Outline: Start/Stop reflects in status and system count/mask within 100 ms -- @1.4   # features/start_stop.feature:19\n    Given the HIL wrapper is connected and ready                                                # None\n    And the DUT is powered and at safe defaults                                                 # None\n    When I write 0 to holding register 40006                                                    # None\n    Then within 100 ms the status flag bit0 for unit 2 equals 0                                 # None\n    And Active Sonicator Count and Mask reflect the running units                               # None\n\nFeature: System metrics # features/system.feature:1\n\n  @pending @req-active-count @reg-40035 @hil\n  Scenario: SC-007 Active Sonicator Count                    # features/system.feature:6\n    Given the system is initialized                          # None\n    When I set input running for unit 1 to asserted          # None\n    Then holding register 40035 should equal 1 within 100 ms # None\n\n  @req-active-mask @reg-40036 @hil\n  Scenario: SC-008 Active Sonicator Mask                     # features/system.feature:12\n    Given the system is initialized                          # None\n    When I set input running for unit 1 to asserted          # None\n    Then holding register 40036 should equal 1 within 100 ms # None\n\n  @req-system-status @reg-40025 @hil\n  Scenario: SC-013 System status bitfield                   # features/system.feature:18\n    Given the system is initialized                         # None\n    When I set input estop for unit 1 to asserted           # None\n    Then holding register 40025 should equal 1 within 50 ms # None\n\n  @req-active-transitions @reg-40035 @reg-40036 @hil\n  Scenario: SC-017 Active transitions stability              # features/system.feature:24\n    Given the system is initialized                          # None\n    When I set input running for unit 1 to deasserted        # None\n    Then holding register 40035 should equal 0 within 100 ms # None\n\nFeature: Complete System Integration Testing # features/system_integration_complete.feature:1\n  As a system integrator\n  I want to verify the complete Multi-Sonicator I/O Controller system functionality\n  So that I can ensure all requirements are met for production deployment\n  Background:   # features/system_integration_complete.feature:6\n\n  @system @integration @critical\n  Scenario: Complete system startup and initialization                       # features/system_integration_complete.feature:13\n    Given the Multi-Sonicator I/O Controller is powered and initialized      # None\n    And all 4 sonicator units are connected and ready                        # None\n    And the MODBUS RTU communication is established at 115200 baud           # None\n    And the system is in a safe default state                                # None\n    Given the system has been powered off                                    # None\n    When I power on the Multi-Sonicator I/O Controller                       # None\n    Then within 2 seconds the system status register should indicate \"READY\" # None\n    And all sonicator units should be in \"STOPPED\" state                     # None\n    And the active sonicator count should be 0                               # None\n    And the active sonicator mask should be 0x0000                           # None\n    And the watchdog status should indicate \"HEALTHY\"                        # None\n    And all amplitude setpoints should default to 50%                        # None\n\n  @system @integration @critical\n  Scenario: Four-sonicator simultaneous operation                       # features/system_integration_complete.feature:24\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given all sonicator units are connected and ready                   # None\n    When I start all 4 sonicators simultaneously                        # None\n    And I set sonicator 1 amplitude to 25%                              # None\n    And I set sonicator 2 amplitude to 50%                              # None\n    And I set sonicator 3 amplitude to 75%                              # None\n    And I set sonicator 4 amplitude to 100%                             # None\n    Then within 200ms all sonicators should be running                  # None\n    And the active sonicator count should be 4                          # None\n    And the active sonicator mask should be 0x000F                      # None\n    And each sonicator should report its correct amplitude              # None\n    And each sonicator should report power consumption > 0 watts        # None\n    And each sonicator should report frequency within operational range # None\n\n  @system @integration @critical\n  Scenario: Sequential sonicator control with monitoring                # features/system_integration_complete.feature:39\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given the system is initialized and ready                           # None\n    When I start sonicator 1 with 30% amplitude                         # None\n    Then within 100ms sonicator 1 should be running at 30% amplitude    # None\n    And the active count should be 1 and mask should be 0x0001          # None\n    When I start sonicator 2 with 60% amplitude                         # None\n    Then within 100ms sonicator 2 should be running at 60% amplitude    # None\n    And the active count should be 2 and mask should be 0x0003          # None\n    When I start sonicator 3 with 90% amplitude                         # None\n    Then within 100ms sonicator 3 should be running at 90% amplitude    # None\n    And the active count should be 3 and mask should be 0x0007          # None\n    When I stop sonicator 2                                             # None\n    Then within 100ms sonicator 2 should be stopped                     # None\n    And the active count should be 2 and mask should be 0x0005          # None\n\n  @system @integration @safety\n  Scenario: Emergency stop functionality                                          # features/system_integration_complete.feature:55\n    Given the Multi-Sonicator I/O Controller is powered and initialized           # None\n    And all 4 sonicator units are connected and ready                             # None\n    And the MODBUS RTU communication is established at 115200 baud                # None\n    And the system is in a safe default state                                     # None\n    Given all 4 sonicators are running at various amplitudes                      # None\n    When I trigger the emergency stop command                                     # None\n    Then within 50ms all sonicators should be stopped                             # None\n    And the emergency stop flag should be set in system status                    # None\n    And the active sonicator count should be 0                                    # None\n    And the active sonicator mask should be 0x0000                                # None\n    And no sonicator should accept start commands until emergency stop is cleared # None\n    When I clear the emergency stop condition                                     # None\n    Then the system should return to normal operation mode                        # None\n    And sonicators should accept start commands again                             # None\n\n  @system @integration @fault-handling\n  Scenario: Overload detection and recovery                             # features/system_integration_complete.feature:68\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given sonicator 1 is running at 75% amplitude                       # None\n    When sonicator 1 experiences an overload condition                  # None\n    Then within 100ms the overload flag should be set for sonicator 1   # None\n    And sonicator 1 should automatically stop                           # None\n    And the active count should decrease by 1                           # None\n    And the system should log the overload event                        # None\n    When I send an overload reset command for sonicator 1               # None\n    Then the overload flag should be cleared                            # None\n    And sonicator 1 should be ready to start again                      # None\n    When I restart sonicator 1                                          # None\n    Then sonicator 1 should operate normally                            # None\n\n  @system @integration @communication\n  Scenario: MODBUS communication reliability under load                 # features/system_integration_complete.feature:82\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given all 4 sonicators are running                                  # None\n    When I perform 100 consecutive MODBUS read operations               # None\n    Then all reads should complete successfully within 100ms each       # None\n    And the CRC should be correct for all responses                     # None\n    And no communication errors should be logged                        # None\n    When I perform 50 consecutive MODBUS write operations               # None\n    Then all writes should complete successfully within 100ms each      # None\n    And all register values should be updated correctly                 # None\n    And the system should maintain stable operation throughout          # None\n\n  @system @integration @performance\n  Scenario: System performance under maximum load                            # features/system_integration_complete.feature:94\n    Given the Multi-Sonicator I/O Controller is powered and initialized      # None\n    And all 4 sonicator units are connected and ready                        # None\n    And the MODBUS RTU communication is established at 115200 baud           # None\n    And the system is in a safe default state                                # None\n    Given all 4 sonicators are connected                                     # None\n    When I start all sonicators at maximum amplitude (100%)                  # None\n    Then each sonicator should reach full power within 500ms                 # None\n    And the total system power consumption should be within specifications   # None\n    And all telemetry data should update at minimum 10Hz                     # None\n    And the system temperature should remain within safe limits              # None\n    And no performance degradation should occur over 10 minutes of operation # None\n\n  @system @integration @timing\n  Scenario: Response time requirements validation                       # features/system_integration_complete.feature:104\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given the system is in normal operation                             # None\n    When I send a start command to any sonicator                        # None\n    Then the command should be acknowledged within 50ms                 # None\n    And the sonicator should begin operation within 200ms               # None\n    And the status should be reflected in MODBUS registers within 100ms # None\n    When I send a stop command to any running sonicator                 # None\n    Then the sonicator should stop within 200ms                         # None\n    And the status change should be reflected within 100ms              # None\n\n  @system @integration @data-integrity\n  Scenario: Telemetry data accuracy and consistency                     # features/system_integration_complete.feature:115\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given sonicator 1 is running at a stable 60% amplitude              # None\n    When I monitor telemetry data for 30 seconds                        # None\n    Then the power readings should be consistent within \u00b15%             # None\n    And the frequency readings should be stable within \u00b11%              # None\n    And the amplitude readings should match the setpoint within \u00b12%     # None\n    And no data corruption or invalid values should occur               # None\n    And the timestamp accuracy should be maintained                     # None\n\n  @system @integration @configuration\n  Scenario: System configuration persistence                            # features/system_integration_complete.feature:125\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given the system is configured with specific settings               # None\n    When I set custom amplitude values for all sonicators               # None\n    And I configure system parameters                                   # None\n    And I power cycle the system                                        # None\n    Then the system should retain all configuration settings            # None\n    And sonicators should return to their configured default states     # None\n    And no configuration drift should occur                             # None\n\n  @pending @system @integration @advanced\n  Scenario: Advanced diagnostics and health monitoring                  # features/system_integration_complete.feature:135\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given the system has been running for extended periods              # None\n    When I request system diagnostics                                   # None\n    Then the system should report component health status               # None\n    And provide runtime statistics for each sonicator                   # None\n    And report any maintenance recommendations                          # None\n    And log historical performance data                                 # None\n    And identify any potential issues before they become critical       # None\n\n  @pending @system @integration @networking\n  Scenario: Multi-controller network operation                          # features/system_integration_complete.feature:145\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given multiple Multi-Sonicator I/O Controllers are networked        # None\n    When I configure unique MODBUS slave IDs for each controller        # None\n    Then each controller should respond only to its assigned ID         # None\n    And network communication should remain stable                      # None\n    And no address conflicts should occur                               # None\n    And centralized monitoring should work correctly                    # None\n\n  @pending @system @integration @calibration\n  Scenario: Automated system calibration                                # features/system_integration_complete.feature:154\n    Given the Multi-Sonicator I/O Controller is powered and initialized # None\n    And all 4 sonicator units are connected and ready                   # None\n    And the MODBUS RTU communication is established at 115200 baud      # None\n    And the system is in a safe default state                           # None\n    Given the system requires calibration                               # None\n    When I initiate the automated calibration sequence                  # None\n    Then the system should calibrate all measurement channels           # None\n    And verify amplitude control accuracy                               # None\n    And adjust power measurement scaling                                # None\n    And validate frequency measurement precision                        # None\n    And store calibration data persistently                             # None\n\nFeature: Timing # features/timing.feature:1\n\n  @pending @req-latency @hil\n  Scenario: SC-009 Latency \u2264100 ms (representative)          # features/timing.feature:6\n    Given the system is initialized                          # None\n    When I simulate starting sonicator 1                     # None\n    Then holding register 40021 should equal 1 within 100 ms # None\n\n  @req-latency @hil\n  Scenario: SC-009B Latency matrix (overload reset, frequency)  # features/timing.feature:12\n    Given the system is initialized                             # None\n    When I write holding register 40009 with value 1            # None\n    Then holding register 40009 should equal 0 within 100 ms    # None\n\n0 features passed, 0 failed, 28 skipped\n0 scenarios passed, 0 failed, 139 skipped\n0 steps passed, 0 failed, 1081 skipped, 0 undefined\nTook 0m0.000s\n",
      "stderr": "",
      "command": "cd test/acceptance && python3 -m behave --dry-run --tags='not @hil' features/"
    },
    "Final Integration Report": {
      "status": "PASS",
      "return_code": 0,
      "stdout": "\ud83d\udd0d Generating comprehensive traceability reports...\n\ud83d\udcc4 Traceability JSON report: /Users/stephenboyett/Desktop/Github/cannasol-technologies/multi-sonicator-io/coverage/traceability_report.json\n\ud83d\udcc4 Traceability HTML report: /Users/stephenboyett/Desktop/Github/cannasol-technologies/multi-sonicator-io/coverage/traceability_report.html\n\u2705 Traceability report generation complete\n\ud83d\udcc8 Overall Status: \u26a0\ufe0f NEEDS WORK\n",
      "stderr": "",
      "command": "python3 scripts/generate_traceability_report.py"
    }
  },
  "overall_status": "FAIL"
}