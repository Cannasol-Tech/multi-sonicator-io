        -:    0:Source:test_communication.c
        -:    0:Graph:test_communication.gcno
        -:    0:Data:test_communication.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/**
        -:    2: * @file test_communication.c
        -:    3: * @brief Comprehensive Unit Tests for MODBUS Communication Module
        -:    4: * @author Cannasol Technologies
        -:    5: * @date 2025-09-04
        -:    6: * @version 1.0.0
        -:    7: *
        -:    8: * @details
        -:    9: * Unity-based unit tests for MODBUS communication module achieving 90% code coverage.
        -:   10: * Tests MODBUS RTU protocol implementation, register management, and error handling.
        -:   11: */
        -:   12:
        -:   13:#ifdef UNIT_TEST
        -:   14:
        -:   15:#include "../unity_config.h"
        -:   16:#include "../../../src/modules/communication/modbus.h"
        -:   17:#include "../../../src/modules/communication/modbus_register_manager.h"
        -:   18:#include "../../../src/modules/communication/modbus_registers.h"
        -:   19:
        -:   20:// ============================================================================
        -:   21:// TEST FIXTURE SETUP
        -:   22:// ============================================================================
        -:   23:
        -:   24:static modbus_config_t test_config;
        -:   25:static uint16_t test_read_value;
        -:   26:static uint16_t test_write_address;
        -:   27:static uint16_t test_write_value;
        -:   28:static bool test_timeout_called;
        -:   29:static bool test_error_called;
        -:   30:static modbus_error_t test_last_error;
        -:   31:
        -:   32:// Test callback functions
    #####:   33:static modbus_error_t test_read_callback(uint16_t address, uint16_t* value) {
    #####:   34:    (void)address;
    #####:   35:    *value = test_read_value;
    #####:   36:    return MODBUS_OK;
        -:   37:}
        -:   38:
    #####:   39:static modbus_error_t test_write_callback(uint16_t address, uint16_t value) {
    #####:   40:    test_write_address = address;
    #####:   41:    test_write_value = value;
    #####:   42:    return MODBUS_OK;
        -:   43:}
        -:   44:
    #####:   45:static void test_timeout_callback(void) {
    #####:   46:    test_timeout_called = true;
    #####:   47:}
        -:   48:
    #####:   49:static void test_error_callback(modbus_error_t error_code) {
    #####:   50:    test_error_called = true;
    #####:   51:    test_last_error = error_code;
    #####:   52:}
        -:   53:
       88:   54:void setUp(void) {
        -:   55:    // Initialize test configuration
       88:   56:    test_config.slave_id = MODBUS_SLAVE_ID;
       88:   57:    test_config.baud_rate = MODBUS_BAUD_RATE;
       88:   58:    test_config.timeout_ms = MODBUS_TIMEOUT_MS;
       88:   59:    test_config.read_callback = test_read_callback;
       88:   60:    test_config.write_callback = test_write_callback;
       88:   61:    test_config.timeout_callback = test_timeout_callback;
       88:   62:    test_config.error_callback = test_error_callback;
        -:   63:
        -:   64:    // Reset test variables
       88:   65:    test_read_value = 0;
       88:   66:    test_write_address = 0;
       88:   67:    test_write_value = 0;
       88:   68:    test_timeout_called = false;
       88:   69:    test_error_called = false;
       88:   70:    test_last_error = MODBUS_OK;
        -:   71:
        -:   72:    // Initialize register manager
       88:   73:    register_manager_init();
       88:   74:}
        -:   75:
       88:   76:void tearDown(void) {
        -:   77:    // Reset MODBUS state
       88:   78:    modbus_set_enabled(false);
       88:   79:    modbus_reset_statistics();
       88:   80:}
        -:   81:
        -:   82:// ============================================================================
        -:   83:// MODBUS CORE FUNCTIONALITY TESTS
        -:   84:// ============================================================================
        -:   85:
        8:   86:void test_modbus_init_valid_config(void) {
        8:   87:    modbus_error_t result = modbus_init(&test_config);
        -:   88:
        8:   89:    TEST_ASSERT_EQUAL(MODBUS_OK, result);
        8:   90:    TEST_ASSERT_TRUE(modbus_is_enabled());
        8:   91:    TEST_ASSERT_EQUAL(MODBUS_STATE_IDLE, modbus_get_state());
        8:   92:    COVERAGE_MARK_FUNCTION(modbus_init);
        8:   93:}
        -:   94:
        8:   95:void test_modbus_init_null_config(void) {
        8:   96:    modbus_error_t result = modbus_init(NULL);
        8:   97:    TEST_ASSERT_EQUAL(MODBUS_ERROR_INVALID_LENGTH, result);
        8:   98:    COVERAGE_MARK_BRANCH(1);
        8:   99:}
        -:  100:
        8:  101:void test_modbus_init_invalid_slave_id(void) {
        8:  102:    test_config.slave_id = 0; // Invalid slave ID
        8:  103:    modbus_error_t result = modbus_init(&test_config);
        8:  104:    TEST_ASSERT_NOT_EQUAL(MODBUS_OK, result);
        8:  105:    COVERAGE_MARK_BRANCH(2);
        8:  106:}
        -:  107:
        8:  108:void test_modbus_validate_address_system_status(void) {
        -:  109:    // Test system status registers (read-only)
        8:  110:    TEST_ASSERT_TRUE(modbus_validate_address(0x0000, MODBUS_FC_READ_HOLDING));
        8:  111:    TEST_ASSERT_TRUE(modbus_validate_address(0x000F, MODBUS_FC_READ_HOLDING));
        8:  112:    TEST_ASSERT_FALSE(modbus_validate_address(0x0000, MODBUS_FC_WRITE_SINGLE));
        8:  113:    TEST_ASSERT_FALSE(modbus_validate_address(0x000F, MODBUS_FC_WRITE_SINGLE));
        8:  114:    COVERAGE_MARK_FUNCTION(modbus_validate_address);
        8:  115:}
        -:  116:
        8:  117:void test_modbus_validate_address_global_control(void) {
        -:  118:    // Test global control registers (read/write)
        8:  119:    TEST_ASSERT_TRUE(modbus_validate_address(0x0010, MODBUS_FC_READ_HOLDING));
        8:  120:    TEST_ASSERT_TRUE(modbus_validate_address(0x001F, MODBUS_FC_READ_HOLDING));
        8:  121:    TEST_ASSERT_TRUE(modbus_validate_address(0x0010, MODBUS_FC_WRITE_SINGLE));
        8:  122:    TEST_ASSERT_TRUE(modbus_validate_address(0x001F, MODBUS_FC_WRITE_SINGLE));
        8:  123:    COVERAGE_MARK_BRANCH(3);
        8:  124:}
        -:  125:
        8:  126:void test_modbus_validate_address_invalid_range(void) {
        -:  127:    // Test invalid address ranges
        8:  128:    TEST_ASSERT_FALSE(modbus_validate_address(0xFFFF, MODBUS_FC_READ_HOLDING));
        8:  129:    TEST_ASSERT_FALSE(modbus_validate_address(0x0500, MODBUS_FC_WRITE_SINGLE));
        8:  130:    COVERAGE_MARK_BRANCH(4);
        8:  131:}
        -:  132:
        8:  133:void test_modbus_calculate_crc_known_values(void) {
        -:  134:    // Test CRC calculation with known values
        8:  135:    uint8_t test_data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01};
        8:  136:    uint16_t calculated_crc = modbus_calculate_crc(test_data, sizeof(test_data));
        -:  137:
        -:  138:    // Test that CRC is calculated (not default values)
        8:  139:    TEST_ASSERT_TRUE(calculated_crc != 0xFFFF);
        8:  140:    TEST_ASSERT_TRUE(calculated_crc != 0x0000);
        8:  141:    COVERAGE_MARK_FUNCTION(modbus_calculate_crc);
        8:  142:}
        -:  143:
        8:  144:void test_modbus_calculate_crc_empty_data(void) {
        8:  145:    uint16_t crc = modbus_calculate_crc(NULL, 0);
        8:  146:    TEST_ASSERT_EQUAL(0xFFFF, crc);
        8:  147:    COVERAGE_MARK_BRANCH(5);
        8:  148:}
        -:  149:
        8:  150:void test_modbus_calculate_crc_consistency(void) {
        8:  151:    uint8_t test_data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01};
        8:  152:    uint16_t crc1 = modbus_calculate_crc(test_data, sizeof(test_data));
        8:  153:    uint16_t crc2 = modbus_calculate_crc(test_data, sizeof(test_data));
        -:  154:
        8:  155:    TEST_ASSERT_EQUAL_UINT16(crc1, crc2);
        8:  156:    COVERAGE_MARK_BRANCH(6);
        8:  157:}
        -:  158:
        8:  159:void test_modbus_enable_disable(void) {
        8:  160:    modbus_init(&test_config);
        -:  161:
        8:  162:    modbus_set_enabled(true);
        8:  163:    TEST_ASSERT_TRUE(modbus_is_enabled());
        8:  164:    TEST_ASSERT_EQUAL(MODBUS_STATE_IDLE, modbus_get_state());
        -:  165:
        8:  166:    modbus_set_enabled(false);
        8:  167:    TEST_ASSERT_FALSE(modbus_is_enabled());
        8:  168:    COVERAGE_MARK_FUNCTION(modbus_set_enabled);
        8:  169:}
        -:  170:
        8:  171:void test_modbus_statistics_tracking(void) {
        8:  172:    modbus_init(&test_config);
        -:  173:
        8:  174:    const modbus_statistics_t* stats = modbus_get_statistics();
        8:  175:    TEST_ASSERT_VALID_POINTER(stats);
        -:  176:
        -:  177:    // Reset and verify
        8:  178:    modbus_reset_statistics();
        8:  179:    TEST_ASSERT_EQUAL(0, stats->requests_received);
        8:  180:    TEST_ASSERT_EQUAL(0, stats->responses_sent);
        8:  181:    TEST_ASSERT_EQUAL(0, stats->crc_errors);
        8:  182:    TEST_ASSERT_EQUAL(0, stats->timeout_errors);
        8:  183:    COVERAGE_MARK_FUNCTION(modbus_get_statistics);
        8:  184:}
        -:  185:
        -:  186:// ============================================================================
        -:  187:// MAIN TEST RUNNER
        -:  188:// ============================================================================
        -:  189:
        8:  190:int main(void) {
        8:  191:    UNITY_BEGIN();
        -:  192:
        -:  193:    // MODBUS Core Tests
        8:  194:    RUN_TEST(test_modbus_init_valid_config);
        8:  195:    RUN_TEST(test_modbus_init_null_config);
        8:  196:    RUN_TEST(test_modbus_init_invalid_slave_id);
        8:  197:    RUN_TEST(test_modbus_validate_address_system_status);
        8:  198:    RUN_TEST(test_modbus_validate_address_global_control);
        8:  199:    RUN_TEST(test_modbus_validate_address_invalid_range);
        8:  200:    RUN_TEST(test_modbus_calculate_crc_known_values);
        8:  201:    RUN_TEST(test_modbus_calculate_crc_empty_data);
        8:  202:    RUN_TEST(test_modbus_calculate_crc_consistency);
        8:  203:    RUN_TEST(test_modbus_enable_disable);
        8:  204:    RUN_TEST(test_modbus_statistics_tracking);
        -:  205:
        8:  206:    return UNITY_END();
        -:  207:}
        -:  208:
        -:  209:#endif // UNIT_TEST
