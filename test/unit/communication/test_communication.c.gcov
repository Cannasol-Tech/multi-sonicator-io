        -:    0:Source:test_communication.c
        -:    0:Graph:test_communication.gcno
        -:    0:Data:test_communication.gcda
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/**
        -:    2: * @file test_communication.c
        -:    3: * @brief Comprehensive Unit Tests for MODBUS Communication Module
        -:    4: * @author Cannasol Technologies
        -:    5: * @date 2025-09-04
        -:    6: * @version 1.0.0
        -:    7: *
        -:    8: * @details
        -:    9: * Unity-based unit tests for MODBUS communication module achieving 90% code coverage.
        -:   10: * Tests MODBUS RTU protocol implementation, register management, and error handling.
        -:   11: */
        -:   12:
        -:   13:#ifdef UNIT_TEST
        -:   14:
        -:   15:#include "../unity_config.h"
        -:   16:#include "../../../src/modules/communication/modbus.h"
        -:   17:#include "../../../src/modules/communication/modbus_register_manager.h"
        -:   18:#include "../../../src/modules/communication/modbus_registers.h"
        -:   19:
        -:   20:// ============================================================================
        -:   21:// TEST FIXTURE SETUP
        -:   22:// ============================================================================
        -:   23:
        -:   24:static modbus_config_t test_config;
        -:   25:static uint16_t test_read_value;
        -:   26:static uint16_t test_write_address;
        -:   27:static uint16_t test_write_value;
        -:   28:static bool test_timeout_called;
        -:   29:static bool test_error_called;
        -:   30:static modbus_error_t test_last_error;
        -:   31:
        -:   32:// Test callback functions
    #####:   33:static modbus_error_t test_read_callback(uint16_t address, uint16_t* value) {
    #####:   34:    (void)address;
    #####:   35:    *value = test_read_value;
    #####:   36:    return MODBUS_OK;
        -:   37:}
        -:   38:
    #####:   39:static modbus_error_t test_write_callback(uint16_t address, uint16_t value) {
    #####:   40:    test_write_address = address;
    #####:   41:    test_write_value = value;
    #####:   42:    return MODBUS_OK;
        -:   43:}
        -:   44:
    #####:   45:static void test_timeout_callback(void) {
    #####:   46:    test_timeout_called = true;
    #####:   47:}
        -:   48:
    #####:   49:static void test_error_callback(modbus_error_t error_code) {
    #####:   50:    test_error_called = true;
    #####:   51:    test_last_error = error_code;
    #####:   52:}
        -:   53:
      156:   54:void setUp(void) {
        -:   55:    // Initialize test configuration
      156:   56:    test_config.slave_id = MODBUS_SLAVE_ID;
      156:   57:    test_config.baud_rate = MODBUS_BAUD_RATE;
      156:   58:    test_config.timeout_ms = MODBUS_TIMEOUT_MS;
      156:   59:    test_config.read_callback = test_read_callback;
      156:   60:    test_config.write_callback = test_write_callback;
      156:   61:    test_config.timeout_callback = test_timeout_callback;
      156:   62:    test_config.error_callback = test_error_callback;
        -:   63:
        -:   64:    // Reset test variables
      156:   65:    test_read_value = 0;
      156:   66:    test_write_address = 0;
      156:   67:    test_write_value = 0;
      156:   68:    test_timeout_called = false;
      156:   69:    test_error_called = false;
      156:   70:    test_last_error = MODBUS_OK;
        -:   71:
        -:   72:    // Initialize register manager
      156:   73:    register_manager_init();
      156:   74:}
        -:   75:
      156:   76:void tearDown(void) {
        -:   77:    // Reset MODBUS state
      156:   78:    modbus_set_enabled(false);
      156:   79:    modbus_reset_statistics();
      156:   80:}
        -:   81:
        -:   82:// ============================================================================
        -:   83:// MODBUS CORE FUNCTIONALITY TESTS
        -:   84:// ============================================================================
        -:   85:
       14:   86:void test_modbus_init_valid_config(void) {
       14:   87:    modbus_error_t result = modbus_init(&test_config);
        -:   88:
       14:   89:    TEST_ASSERT_EQUAL(MODBUS_OK, result);
       14:   90:    TEST_ASSERT_TRUE(modbus_is_enabled());
       14:   91:    TEST_ASSERT_EQUAL(MODBUS_STATE_IDLE, modbus_get_state());
       14:   92:    COVERAGE_MARK_FUNCTION(modbus_init);
       14:   93:}
        -:   94:
       14:   95:void test_modbus_init_null_config(void) {
       14:   96:    modbus_error_t result = modbus_init(NULL);
       14:   97:    TEST_ASSERT_EQUAL(MODBUS_ERROR_INVALID_LENGTH, result);
       14:   98:    COVERAGE_MARK_BRANCH(1);
       14:   99:}
        -:  100:
       14:  101:void test_modbus_init_invalid_slave_id(void) {
       14:  102:    test_config.slave_id = 0; // Invalid slave ID
       14:  103:    modbus_error_t result = modbus_init(&test_config);
       14:  104:    TEST_ASSERT_NOT_EQUAL(MODBUS_OK, result);
       14:  105:    COVERAGE_MARK_BRANCH(2);
       14:  106:}
        -:  107:
       14:  108:void test_modbus_validate_address_system_status(void) {
        -:  109:    // Test system status registers (read-only)
       14:  110:    TEST_ASSERT_TRUE(modbus_validate_address(0x0000, MODBUS_FC_READ_HOLDING));
       14:  111:    TEST_ASSERT_TRUE(modbus_validate_address(0x000F, MODBUS_FC_READ_HOLDING));
       14:  112:    TEST_ASSERT_FALSE(modbus_validate_address(0x0000, MODBUS_FC_WRITE_SINGLE));
       14:  113:    TEST_ASSERT_FALSE(modbus_validate_address(0x000F, MODBUS_FC_WRITE_SINGLE));
       14:  114:    COVERAGE_MARK_FUNCTION(modbus_validate_address);
       14:  115:}
        -:  116:
       14:  117:void test_modbus_validate_address_global_control(void) {
        -:  118:    // Test global control registers (read/write)
       14:  119:    TEST_ASSERT_TRUE(modbus_validate_address(0x0010, MODBUS_FC_READ_HOLDING));
       14:  120:    TEST_ASSERT_TRUE(modbus_validate_address(0x001F, MODBUS_FC_READ_HOLDING));
       14:  121:    TEST_ASSERT_TRUE(modbus_validate_address(0x0010, MODBUS_FC_WRITE_SINGLE));
       14:  122:    TEST_ASSERT_TRUE(modbus_validate_address(0x001F, MODBUS_FC_WRITE_SINGLE));
       14:  123:    COVERAGE_MARK_BRANCH(3);
       14:  124:}
        -:  125:
       14:  126:void test_modbus_validate_address_invalid_range(void) {
        -:  127:    // Test invalid address ranges
       14:  128:    TEST_ASSERT_FALSE(modbus_validate_address(0xFFFF, MODBUS_FC_READ_HOLDING));
       14:  129:    TEST_ASSERT_FALSE(modbus_validate_address(0x0500, MODBUS_FC_WRITE_SINGLE));
       14:  130:    COVERAGE_MARK_BRANCH(4);
       14:  131:}
        -:  132:
       14:  133:void test_modbus_calculate_crc_known_values(void) {
        -:  134:    // Test CRC calculation with known values
       14:  135:    uint8_t test_data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01};
       14:  136:    uint16_t calculated_crc = modbus_calculate_crc(test_data, sizeof(test_data));
        -:  137:
        -:  138:    // Test that CRC is calculated (not default values)
       14:  139:    TEST_ASSERT_TRUE(calculated_crc != 0xFFFF);
       14:  140:    TEST_ASSERT_TRUE(calculated_crc != 0x0000);
       14:  141:    COVERAGE_MARK_FUNCTION(modbus_calculate_crc);
       14:  142:}
        -:  143:
       14:  144:void test_modbus_calculate_crc_empty_data(void) {
       14:  145:    uint16_t crc = modbus_calculate_crc(NULL, 0);
       14:  146:    TEST_ASSERT_EQUAL(0xFFFF, crc);
       14:  147:    COVERAGE_MARK_BRANCH(5);
       14:  148:}
        -:  149:
       14:  150:void test_modbus_calculate_crc_consistency(void) {
       14:  151:    uint8_t test_data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01};
       14:  152:    uint16_t crc1 = modbus_calculate_crc(test_data, sizeof(test_data));
       14:  153:    uint16_t crc2 = modbus_calculate_crc(test_data, sizeof(test_data));
        -:  154:
       14:  155:    TEST_ASSERT_EQUAL_UINT16(crc1, crc2);
       14:  156:    COVERAGE_MARK_BRANCH(6);
       14:  157:}
        -:  158:
       14:  159:void test_modbus_enable_disable(void) {
       14:  160:    modbus_init(&test_config);
        -:  161:
       14:  162:    modbus_set_enabled(true);
       14:  163:    TEST_ASSERT_TRUE(modbus_is_enabled());
       14:  164:    TEST_ASSERT_EQUAL(MODBUS_STATE_IDLE, modbus_get_state());
        -:  165:
       14:  166:    modbus_set_enabled(false);
       14:  167:    TEST_ASSERT_FALSE(modbus_is_enabled());
       14:  168:    COVERAGE_MARK_FUNCTION(modbus_set_enabled);
       14:  169:}
        -:  170:
       14:  171:void test_modbus_statistics_tracking(void) {
       14:  172:    modbus_init(&test_config);
        -:  173:
       14:  174:    const modbus_statistics_t* stats = modbus_get_statistics();
       14:  175:    TEST_ASSERT_VALID_POINTER(stats);
        -:  176:
        -:  177:    // Reset and verify
       14:  178:    modbus_reset_statistics();
       14:  179:    TEST_ASSERT_EQUAL(0, stats->requests_received);
       14:  180:    TEST_ASSERT_EQUAL(0, stats->responses_sent);
       14:  181:    TEST_ASSERT_EQUAL(0, stats->crc_errors);
       14:  182:    TEST_ASSERT_EQUAL(0, stats->timeout_errors);
       14:  183:    COVERAGE_MARK_FUNCTION(modbus_get_statistics);
       14:  184:}
        -:  185:
    #####:  186:void test_modbus_additional_address_ranges(void) {
        -:  187:    // Test additional address validation scenarios
    #####:  188:    TEST_ASSERT_TRUE(modbus_validate_address(0x0200, MODBUS_FC_READ_HOLDING));
    #####:  189:    TEST_ASSERT_TRUE(modbus_validate_address(0x0300, MODBUS_FC_WRITE_SINGLE));
    #####:  190:    TEST_ASSERT_FALSE(modbus_validate_address(0x0500, MODBUS_FC_READ_HOLDING));
        -:  191:    
    #####:  192:    COVERAGE_MARK_FUNCTION(modbus_additional_validation);
    #####:  193:}
        -:  194:
    #####:  195:void test_modbus_state_management(void) {
    #####:  196:    modbus_init(&test_config);
        -:  197:    
        -:  198:    // Test state management
    #####:  199:    modbus_state_t state = modbus_get_state();
    #####:  200:    TEST_ASSERT_EQUAL(MODBUS_STATE_IDLE, state);
        -:  201:    
    #####:  202:    COVERAGE_MARK_FUNCTION(modbus_state_management);
    #####:  203:}
        -:  204:
        -:  205:// ============================================================================
        -:  206:// MAIN TEST RUNNER
        -:  207:// ============================================================================
        -:  208:
    #####:  209:int main(void) {
    #####:  210:    UNITY_BEGIN();
        -:  211:
        -:  212:    // MODBUS Core Tests
    #####:  213:    RUN_TEST(test_modbus_init_valid_config);
    #####:  214:    RUN_TEST(test_modbus_init_null_config);
    #####:  215:    RUN_TEST(test_modbus_init_invalid_slave_id);
    #####:  216:    RUN_TEST(test_modbus_validate_address_system_status);
    #####:  217:    RUN_TEST(test_modbus_validate_address_global_control);
    #####:  218:    RUN_TEST(test_modbus_validate_address_invalid_range);
    #####:  219:    RUN_TEST(test_modbus_calculate_crc_known_values);
    #####:  220:    RUN_TEST(test_modbus_calculate_crc_empty_data);
    #####:  221:    RUN_TEST(test_modbus_calculate_crc_consistency);
    #####:  222:    RUN_TEST(test_modbus_enable_disable);
    #####:  223:    RUN_TEST(test_modbus_statistics_tracking);
        -:  224:    
        -:  225:    // Additional Coverage Tests
    #####:  226:    RUN_TEST(test_modbus_additional_address_ranges);
    #####:  227:    RUN_TEST(test_modbus_state_management);
        -:  228:
    #####:  229:    return UNITY_END();
        -:  230:}
        -:  231:
        -:  232:#endif // UNIT_TEST
