/**
 * @file test_hal_gpio.cpp
 * @brief Unit tests for HAL GPIO module
 * @author Cannasol Technologies
 * @date 2025-09-02
 * @version 1.0.0
 * 
 * Following unity-testing-guide.md patterns for comprehensive HAL testing
 * with mock objects and proper test organization.
 */

#include <unity.h>

#ifdef NATIVE_TEST
#include "../../../src/modules/hal/hal_mock_factory.h"
#else
#include "hal_mock_factory.h"
#endif

// ============================================================================
// TEST FIXTURES
// ============================================================================

static MockHalFactory* mock_factory;
static MockGpioPort* mock_gpio;

void setUp(void) {
    mock_factory = new MockHalFactory();
    mock_gpio = mock_factory->getMockGpio();
    mock_gpio->reset();
}

void tearDown(void) {
    delete mock_factory;
    mock_factory = nullptr;
    mock_gpio = nullptr;
}

// ============================================================================
// INITIALIZATION TESTS
// ============================================================================

void test_gpio_init_success(void) {
    gpio_result_t result = gpio_init();
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

void test_gpio_init_sonicator_pins(void) {
    gpio_result_t result = gpio_init_sonicator_pins();
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

// ============================================================================
// PIN MODE CONFIGURATION TESTS
// ============================================================================

void test_gpio_set_pin_mode_valid_pins(void) {
    // Test various pin modes on valid pins
    gpio_result_t result = gpio_set_pin_mode(STATUS_LED_PIN, GPIO_MODE_OUTPUT);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    
    result = gpio_set_pin_mode(SON1_OVERLOAD_PIN, GPIO_MODE_INPUT_PULLUP);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

void test_gpio_set_pin_mode_invalid_pin(void) {
    gpio_result_t result = gpio_set_pin_mode(255, GPIO_MODE_OUTPUT);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_set_pin_mode_invalid_mode(void) {
    gpio_result_t result = gpio_set_pin_mode(STATUS_LED_PIN, (gpio_mode_t)99);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_MODE, result);
}

void test_gpio_set_pin_mode_not_initialized(void) {
    // Reset initialization state (this is a bit of a hack for testing)
    // In real implementation, would need a way to uninitialize
    gpio_result_t result = gpio_set_pin_mode(STATUS_LED_PIN, GPIO_MODE_OUTPUT);
    // Should still work as Arduino framework handles this
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

// ============================================================================
// PIN WRITE/READ TESTS
// ============================================================================

void test_gpio_write_pin_valid(void) {
    gpio_set_pin_mode(STATUS_LED_PIN, GPIO_MODE_OUTPUT);
    
    gpio_result_t result = gpio_write_pin(STATUS_LED_PIN, GPIO_HIGH);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    
    result = gpio_write_pin(STATUS_LED_PIN, GPIO_LOW);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

void test_gpio_write_pin_invalid(void) {
    gpio_result_t result = gpio_write_pin(255, GPIO_HIGH);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_read_pin_valid(void) {
    gpio_state_t state;
    gpio_set_pin_mode(SON1_OVERLOAD_PIN, GPIO_MODE_INPUT_PULLUP);
    
    gpio_result_t result = gpio_read_pin(SON1_OVERLOAD_PIN, &state);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    // With pullup, should read HIGH
    TEST_ASSERT_EQUAL(GPIO_HIGH, state);
}

void test_gpio_read_pin_invalid(void) {
    gpio_state_t state;
    gpio_result_t result = gpio_read_pin(255, &state);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_read_pin_null_pointer(void) {
    gpio_result_t result = gpio_read_pin(SON1_OVERLOAD_PIN, nullptr);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_toggle_pin(void) {
    gpio_set_pin_mode(STATUS_LED_PIN, GPIO_MODE_OUTPUT);
    gpio_write_pin(STATUS_LED_PIN, GPIO_LOW);
    
    gpio_result_t result = gpio_toggle_pin(STATUS_LED_PIN);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    
    gpio_state_t state;
    gpio_read_pin(STATUS_LED_PIN, &state);
    TEST_ASSERT_EQUAL(GPIO_HIGH, state);
}

// ============================================================================
// SONICATOR INTERFACE TESTS
// ============================================================================

void test_gpio_sonicator_start_valid(void) {
    for (uint8_t i = 1; i <= MAX_SONICATORS; i++) {
        gpio_result_t result = gpio_sonicator_start(i);
        TEST_ASSERT_EQUAL(GPIO_OK, result);
    }
}

void test_gpio_sonicator_start_invalid(void) {
    gpio_result_t result = gpio_sonicator_start(0);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
    
    result = gpio_sonicator_start(MAX_SONICATORS + 1);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_sonicator_stop_valid(void) {
    for (uint8_t i = 1; i <= MAX_SONICATORS; i++) {
        gpio_result_t result = gpio_sonicator_stop(i);
        TEST_ASSERT_EQUAL(GPIO_OK, result);
    }
}

void test_gpio_sonicator_reset(void) {
    gpio_result_t result = gpio_sonicator_reset(1);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

void test_gpio_sonicator_read_overload(void) {
    bool overload;
    gpio_result_t result = gpio_sonicator_read_overload(1, &overload);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    // With pullup and no actual sonicator, should read as no overload (false)
    TEST_ASSERT_FALSE(overload);
}

void test_gpio_sonicator_read_overload_null_pointer(void) {
    gpio_result_t result = gpio_sonicator_read_overload(1, nullptr);
    TEST_ASSERT_EQUAL(GPIO_ERROR_INVALID_PIN, result);
}

void test_gpio_sonicator_read_freq_lock(void) {
    bool locked;
    gpio_result_t result = gpio_sonicator_read_freq_lock(1, &locked);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    // With pullup, should read as locked (true)
    TEST_ASSERT_TRUE(locked);
}

void test_gpio_status_led(void) {
    gpio_result_t result = gpio_status_led(GPIO_HIGH);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
    
    result = gpio_status_led(GPIO_LOW);
    TEST_ASSERT_EQUAL(GPIO_OK, result);
}

// ============================================================================
// PIN MATRIX COMPLIANCE TESTS
// ============================================================================

void test_gpio_pin_matrix_compliance(void) {
    // Test that all pins defined in pin matrix are valid
    TEST_ASSERT_TRUE(SON1_OVERLOAD_PIN <= 31);
    TEST_ASSERT_TRUE(SON1_FREQ_OUTPUT_PIN <= 31);
    TEST_ASSERT_TRUE(SON1_FREQ_LOCK_PIN <= 31);
    TEST_ASSERT_TRUE(SON1_START_PIN <= 31);
    TEST_ASSERT_TRUE(SON1_RESET_PIN <= 31);
    
    TEST_ASSERT_TRUE(SON2_OVERLOAD_PIN <= 31);
    TEST_ASSERT_TRUE(SON2_FREQ_OUTPUT_PIN <= 31);
    TEST_ASSERT_TRUE(SON2_FREQ_LOCK_PIN <= 31);
    TEST_ASSERT_TRUE(SON2_START_PIN <= 31);
    TEST_ASSERT_TRUE(SON2_RESET_PIN <= 31);
    
    TEST_ASSERT_TRUE(SON3_OVERLOAD_PIN <= 31);
    TEST_ASSERT_TRUE(SON3_FREQ_OUTPUT_PIN <= 31);
    TEST_ASSERT_TRUE(SON3_FREQ_LOCK_PIN <= 31);
    TEST_ASSERT_TRUE(SON3_START_PIN <= 31);
    TEST_ASSERT_TRUE(SON3_RESET_PIN <= 31);
    
    TEST_ASSERT_TRUE(SON4_OVERLOAD_PIN <= 31);
    TEST_ASSERT_TRUE(SON4_FREQ_OUTPUT_PIN <= 31);
    TEST_ASSERT_TRUE(SON4_FREQ_LOCK_PIN <= 31);
    TEST_ASSERT_TRUE(SON4_START_PIN <= 31);
    TEST_ASSERT_TRUE(SON4_RESET_PIN <= 31);
    
    TEST_ASSERT_TRUE(STATUS_LED_PIN <= 31);
}

// ============================================================================
// TEST RUNNER
// ============================================================================

int main(void) {
    UNITY_BEGIN();
    
    // Initialization tests
    RUN_TEST(test_gpio_init_success);
    RUN_TEST(test_gpio_init_sonicator_pins);
    
    // Pin mode tests
    RUN_TEST(test_gpio_set_pin_mode_valid_pins);
    RUN_TEST(test_gpio_set_pin_mode_invalid_pin);
    RUN_TEST(test_gpio_set_pin_mode_invalid_mode);
    RUN_TEST(test_gpio_set_pin_mode_not_initialized);
    
    // Pin write/read tests
    RUN_TEST(test_gpio_write_pin_valid);
    RUN_TEST(test_gpio_write_pin_invalid);
    RUN_TEST(test_gpio_read_pin_valid);
    RUN_TEST(test_gpio_read_pin_invalid);
    RUN_TEST(test_gpio_read_pin_null_pointer);
    RUN_TEST(test_gpio_toggle_pin);
    
    // Sonicator interface tests
    RUN_TEST(test_gpio_sonicator_start_valid);
    RUN_TEST(test_gpio_sonicator_start_invalid);
    RUN_TEST(test_gpio_sonicator_stop_valid);
    RUN_TEST(test_gpio_sonicator_reset);
    RUN_TEST(test_gpio_sonicator_read_overload);
    RUN_TEST(test_gpio_sonicator_read_overload_null_pointer);
    RUN_TEST(test_gpio_sonicator_read_freq_lock);
    RUN_TEST(test_gpio_status_led);
    
    // Pin matrix compliance tests
    RUN_TEST(test_gpio_pin_matrix_compliance);
    
    return UNITY_END();
}
