# Story 2.5: WebSocket Handler Improvements
## Goal
Improve the reliability and robustness of the WebSocket handler in the backend to ensure accurate command/response pairing and better error detection.

## Background
The WebSocket handler is responsible for managing communication between the web UI and the hardware interface. It broadcasts hardware events to connected clients and routes client commands to the hardware layer. To ensure reliable operation, we need to improve error handling and command matching algorithms.

## Requirements

### 1. Enhanced Error Detection
- Make error checking case-insensitive to catch errors regardless of their case
- Improve reliability of error detection for command responses

### 2. Improved Command Matching
- Implement a more sophisticated algorithm for pairing sent commands with received responses
- Ensure accurate matching even when multiple commands are sent in quick succession

## Implementation Plan

### 1. Case-Insensitive Error Checking
Modify the error checking logic in the `setupHardwareListeners` method to use case-insensitive matching:
```javascript
// Before
success: !commandData.data.includes('ERROR') && !commandData.data.includes('FAIL'),
error: commandData.data.includes('ERROR') || commandData.data.includes('FAIL') ? commandData.data : undefined,

// After
success: !commandData.data.toLowerCase().includes('error') && !commandData.data.toLowerCase().includes('fail'),
error: (commandData.data.toLowerCase().includes('error') || commandData.data.toLowerCase().includes('fail')) ? commandData.data : undefined,
```

### 2. Enhanced Command Matching Algorithm
Replace the simple "most recent command" approach with a more sophisticated matching algorithm:
1. First try to match responses with commands of the same type
2. Fall back to the most recent command if no type match is found

```javascript
// Enhanced matching algorithm
let matchedEntry = null;
let responseTime = 0;

// Try to find a command of the same type first
const commandType = commandData.type;
const sameTypeCommands = Array.from(this.pendingCommands.entries())
    .filter(([id, info]) => id.endsWith(`-${commandType}`))
    .sort((a, b) => b[1].timestamp - a[1].timestamp);

if (sameTypeCommands.length > 0) {
    const [commandId, commandInfo] = sameTypeCommands[0];
    matchedEntry = { commandId, commandInfo };
} else {
    // Fallback to most recent command (previous approach)
    const recentCommands = Array.from(this.pendingCommands.entries())
        .sort((a, b) => b[1].timestamp - a[1].timestamp);
    if (recentCommands.length > 0) {
        const [commandId, commandInfo] = recentCommands[0];
        matchedEntry = { commandId, commandInfo };
    }
}

if (matchedEntry) {
    matchedCommand = matchedEntry.commandInfo.command;
    responseTime = commandData.timestamp - matchedEntry.commandInfo.timestamp;
    this.pendingCommands.delete(matchedEntry.commandId);
}
```

## Acceptance Criteria
- [ ] Error detection works correctly for various case combinations of "ERROR" and "FAIL"
- [ ] Command/response pairing is accurate even with multiple concurrent commands
- [ ] No regressions in existing functionality
- [ ] All tests pass

## Testing
- Unit tests for error detection logic with various case combinations
- Integration tests for command/response pairing with multiple concurrent commands
- Manual testing of WebSocket communication with hardware interface

## Dependencies
None

## Estimated Effort
2 hours

## Priority
Medium