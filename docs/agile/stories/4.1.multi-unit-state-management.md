---
# <!-- Generated by •∆• ~•Axovia•ƒløw™•~ -->
id: S-4.1
title: Multi-Unit State Management
status: in-progress
updated_at: 2025-09-15
version: 1.0
provenance:
  banner: "<!-- Generated by •∆• ~•Axovia•ƒløw™•~ -->"
---
# Story 4.1: Multi-Unit State Management

## Status

In Progress

## Story

**As a** Control Systems Engineer,
**I want** coordinated state machines for managing up to 4 sonicator units simultaneously,
**so that** I can ensure safe, efficient, and synchronized operation of multiple sonicators with proper state coordination and conflict resolution.

## Acceptance Criteria

1. State machine implementation for each of 4 sonicator units
2. Master coordination state machine for multi-unit orchestration
3. State synchronization and conflict resolution mechanisms
4. Safe state transitions with validation and interlocks
5. State persistence and recovery after power cycles
6. Real-time state monitoring and reporting via MODBUS
7. Emergency state management and shutdown procedures
8. State machine testing with all possible transitions
9. Performance optimization for concurrent state management
10. Integration with safety systems and overload protection
11. Read-only MODBUS registers expose previous-state context (no auto-resume)
    - System-level (read-only):
      - 0x0005 PREV_ACTIVE_MASK — bitmask of units active before last shutdown
      - 0x0006 LAST_SHUTDOWN_REASON — 0=normal, 1=watchdog, 2=power-loss, 3=e-stop, 4=fault
    - Per-unit (read-only, status block):
      - 0xN14 PREV_STATE — last recorded unit state (enum sonicator_state_t)
      - 0xN15 PERSISTED_AMPLITUDE — last setpoint before shutdown
      - 0xN16 LAST_FAULT_CODE — last recorded fault code for unit
      - 0xN17 LAST_STATE_TIMESTAMP_LO — low 16 bits of timestamp (hi optional)
    - Safety rule: On power-up, master=IDLE and all units=STOPPED regardless of persisted values
12. Per‑unit start/stop control with abort semantics
    - Receiving a STOP for a unit aborts any in‑flight START for that specific unit
    - Receiving a START for a unit aborts any in‑flight STOP for that specific unit
    - Other units continue unaffected by a unit‑level abort
13. Partial success on coordinated operations
    - If a coordinated START is requested for multiple units, units that successfully start shall continue RUNNING even if one or more units fail
    - Units that fail to start must transition to an appropriate error state (e.g., OVERLOAD/FAULT) per single‑unit policy; no auto‑resume
14. Per‑unit aborts during coordinated operations
    - During a coordinated START, issuing a per‑unit STOP aborts START for that specific unit; other units continue to RUNNING
    - During a coordinated STOP, issuing a per‑unit START aborts STOP for that specific unit; other units continue to STOP
15. Start-timeout path
    - If a unit remains in STARTING beyond the configured window without meeting start criteria, it transitions to an error state (FAULT/OVERLOAD)
    - Other units continue running; the timed-out unit is removed from the active mask and requires explicit recovery

## Tasks / Subtasks

- [ ] Task 1: Individual Sonicator State Machines (AC: 1, 4)
  - [ ] Design state machine for single sonicator unit
  - [ ] Implement states: OFF, STARTING, RUNNING, STOPPING, FAULT, MAINTENANCE
  - [ ] Create state transition validation and safety checks
  - [ ] Implement state-specific behavior and actions
  - [ ] Add state machine unit tests and validation

- [ ] Task 2: Master Coordination State Machine (AC: 2, 3)
  - [x] Design master state machine for multi-unit coordination
  - [x] Implement coordination states: IDLE, COORDINATED_START, RUNNING, EMERGENCY_STOP
  - [ ] Create state synchronization mechanisms
  - [ ] Implement conflict resolution algorithms
  - [x] Add master state machine testing
  - [x] Implement coordinated stop for selected units (all-units path)
  - [x] Add unit test for coordinated stop
- [x] Add per‑unit START/STOP commands with abort semantics (AC: 12)
  - [x] Add tests for partial success behavior and error routing (AC: 13)
  - [x] Add acceptance scenarios for per‑unit abort during coordinated operations (AC: 14)
  - [x] Add unit test covering start-timeout path with start-inhibit (AC: 15)

- [ ] Task 3: State Persistence and Recovery (AC: 5, 6)
  - [ ] Implement state persistence to EEPROM
  - [ ] Create power-cycle recovery procedures
  - [ ] Add state validation after recovery
  - [ ] Implement MODBUS state reporting
  - [ ] Create state history and logging

- [ ] Task 4: Emergency and Safety Integration (AC:` 7, 10)
  - [ ] Implement emergency shutdown state transitions
  - [ ] Create safety interlock integration
  - [ ] Add overload protection state handling
  - [ ] Implement fault isolation and recovery
  - [ ] Create safety system testing

- [ ] Task 5: Performance and Testing (AC: 8, 9)
  - [ ] Optimize state machine performance for real-time operation
  - [ ] Create comprehensive state transition testing
  - [ ] Implement concurrent operation validation
  - [ ] Add performance monitoring and metrics
  - [ ] Create load testing for 4-unit operation

## Dev Notes

### Testing Standards

- **Test Framework**: Unity with state machine test harness
- **Test Location**: test/unit/state_machines/ and test/integration/coordination/
- **Coverage Target**: 100% state transition coverage required
- **State Testing**: All possible state combinations and transitions
- **Performance Testing**: Real-time operation validation under load

### Architecture Context

- **State Management**: Hierarchical state machines with master coordination
- **Memory Usage**: Efficient state storage in constrained 2KB SRAM
- **Real-time**: State transitions within deterministic timing bounds
- **Communication**: MODBUS register mapping for state reporting
- **Safety Integration**: Integration with hardware safety systems

### Technical Constraints

- **Memory Limitations**: Minimize state machine memory footprint
- **Real-time Performance**: State transitions ≤10ms for responsiveness
- **Safety Critical**: All state transitions must be safe and validated
- **Concurrent Operation**: Support 4 simultaneous state machines
- **Fault Tolerance**: Graceful degradation and recovery capabilities

### File Locations

- **State Machine Headers**: include/state_machines/ (state machine interfaces)
- **State Machine Source**: src/state_machines/ (implementation files)
- **State Tests**: test/unit/state_machines/ (unit tests)
- **Integration Tests**: test/integration/coordination/ (multi-unit tests)
- **State Configuration**: include/config/state_config.h (state definitions)

### State Machine Design

```c
// Sonicator State Enumeration
typedef enum {
    SONICATOR_STATE_OFF,
    SONICATOR_STATE_STARTING,
    SONICATOR_STATE_RUNNING,
    SONICATOR_STATE_STOPPING,
    SONICATOR_STATE_FAULT,
    SONICATOR_STATE_MAINTENANCE
} sonicator_state_t;

// Master Coordination States
typedef enum {
    MASTER_STATE_IDLE,
    MASTER_STATE_COORDINATED_START,
    MASTER_STATE_RUNNING,
    MASTER_STATE_EMERGENCY_STOP,
    MASTER_STATE_FAULT_ISOLATION
} master_state_t;

// State Machine Interface
typedef struct {
    sonicator_state_t current_state;
    sonicator_state_t previous_state;
    uint32_t state_entry_time;
    uint16_t fault_code;
    bool state_change_pending;
} sonicator_state_machine_t;
```

### State Transition Matrix

- **Valid Transitions**: Defined transition matrix for safety
- **Transition Guards**: Conditions that must be met for transitions
- **Transition Actions**: Actions performed during state changes
- **Timeout Handling**: Maximum time limits for each state
- **Error Recovery**: Automatic recovery from transient faults

### MODBUS State Reporting

- **State Registers**: Individual sonicator state reporting
- **Master State**: Overall system coordination state
- **State History**: Recent state change log
- **Fault Information**: Detailed fault codes and timestamps
- **Performance Metrics**: State transition timing and statistics

### Previous Story Insights

- Depends on Epic 1 HAL and basic control implementation
- Foundation for all multi-unit coordination features
- Critical for safety and operational reliability
- Must integrate with existing single-unit control patterns

## Dev Agent Record

### Agent Model Used
- .github/chatmodes/dev.chatmode.md (James — Full Stack Developer)

### Debug Log References
- Added pending BDD scenarios for AC‑5 safe recovery and AC‑11 read-only previous-state registers
- Extended MODBUS register map structures with read-only previous-state fields
- Initialized new fields with safe defaults in Register Manager
- Snapshot previous-state context on EMERGENCY_STOP and global disable in MODBUS layer
- Implemented coordinated stop path: RUNNING → STOPPING (selected) → STOPPED with mask update; master returns to IDLE when mask=0
- Added unit test covering coordinated stop of all units
- Added unit tests covering partial success behavior and error routing (AC‑13)

### Completion Notes
- Acceptance tests created and tagged @pending where hardware/HIL is required
- Unit tests added for new register addresses and read-only classification
- No auto-resume on reboot; system always boots with all units STOPPED and master IDLE
- Coordinated stop implemented for all-units path; unit tests added and passing locally
- Per‑unit START/STOP abort behavior implemented and unit‑tested; acceptance scenarios added
- AC‑14 (per‑unit abort during coordinated ops) scenarios added and active; AC‑13 (partial success) scenarios present and marked @pending pending HIL validation

### File List
- test/acceptance/features/multi_unit_state_management.feature (added)
  - updated: added scenarios for AC‑12 and AC‑14; AC‑13 present and marked @pending
- test/unit/test_prev_state_registers.cpp (added)
- test/unit/control/test_multi_sonicator.cpp (added)
- include/multi_sonicator.h (added)
- src/modules/control/multi_sonicator.cpp (added)
  - updated: coordinated stop implementation and RUNNING-state stop progression
- src/modules/communication/modbus_registers.h (updated)
- include/register_map.h (updated)
- src/modules/communication/modbus_register_manager.cpp (updated)
- src/modules/communication/modbus.cpp (updated)


## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-10 | 1.0 | Created story for multi-unit state management | Product Owner |
| 2025-09-15 | 1.1 | Added AC‑11 read-only previous-state registers; updated AC‑5 to safe recovery | Dev |
| 2025-09-15 | 1.2 | Added pending BDD scenarios; implemented register map fields and unit tests | Dev |
| 2025-09-15 | 1.3 | Implemented coordinated stop and added unit tests | Dev |
| 2025-09-15 | 1.4 | Added per‑unit abort semantics and partial‑success requirements to Acceptance Criteria; implemented per‑unit APIs | Dev |

## QA Results

### Review Date: 2025-09-16

### Reviewed By: Quinn (Test Architect)

### Summary
- Gate Decision: CONCERNS (see `docs/qa/gates/4.1-multi-unit-state-management.yml`)
- Rationale: Core coordination present with unit tests; persistence/recovery, safety interlocks/E‑STOP, and full acceptance/HIL validation remain incomplete.

### Evidence Snapshot
- Unit tests present: `test/unit/control/test_multi_sonicator.cpp`, `test/unit/test_prev_state_registers.cpp`
- Acceptance feature present: `test/acceptance/features/multi_unit_state_management.feature` (some scenarios @pending)
- Implementation present: `src/modules/control/multi_sonicator.cpp`
- Traceability: `docs/traceability/bdd_traceability_matrix.csv` shows S-4.1 items marked ready/pending
- Story tasks indicate AC 3, 5, 6, 7, 8, 9, 10 incomplete

### Top Findings
1. Persistence & Recovery (AC‑5/6): Not implemented or verified; no power‑cycle tests.
2. Safety & Interlocks (AC‑7/10): E‑STOP and safety integration incomplete; no HIL evidence.
3. Partial Success (AC‑13): BDD scenarios present but @pending; not validated end‑to‑end.
4. Performance & Coverage (AC‑8/9): Real‑time timing and full transition coverage not demonstrated.
5. MODBUS Prev‑State (AC‑11): RO fields added and unit‑tested; integration/HIL validation pending.

### Recommended Next Steps
- Implement EEPROM persistence and safe boot recovery; add power‑cycle tests and BDD scenarios.
- Complete E‑STOP and interlock paths; add unit/integration tests and HIL validation.
- Activate and pass AC‑13 acceptance scenarios; include partial‑success logs/metrics.
- Add transition coverage tests and timing assertions (≤10ms); document results.
- Validate AC‑11 mapping/RO behavior via integration/HIL tests.

### Gate Contexts
- Status contexts tracked: ci/unit, ci/integration, ci/acceptance, standards/check, lint/markdown

### Developer Instructions (Hardware deferral approved)
- Proceed to finish all non‑hardware items now:
  - AC‑5/6: Implement persistence + safe recovery and add power‑cycle tests (software/sim acceptable).
  - AC‑7/10: Complete E‑STOP + safety interlocks in code and cover with unit/integration tests.
  - AC‑8/9: Add transition‑coverage tests and real‑time timing assertions (≤10ms) in CI.
  - AC‑13: Enable BDD scenarios (remove @pending) and make them pass in CI.
  - AC‑11: Verify RO/mapping via integration tests against register map.
- Hardware/HIL verification is temporarily deferred. Keep HIL scenarios tagged @pending and add TODOs noting “Awaiting hardware availability”.
- When hardware becomes available, run HIL tests and attach results to close remaining concerns.
